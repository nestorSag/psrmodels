<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>psrmodels.time_collapsed.BivariateHindcastMargin API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>psrmodels.time_collapsed.BivariateHindcastMargin</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
from scipy.optimize import bisect

import pandas as pd
import math

from .BivariateConvGenDist import * 
from .UnivariateHindcastMargin import *

from _c_ext_bivarmargins import ffi, lib as C_CALL

from warnings import warn

class BivariateHindcastMargin(object):
  &#34;&#34;&#34;Main class for risk calculations in a time-collapsed 2-area hindcast model.
  It receives demand and wind generation data as opposed to just net demand data, to make it posible to calculate
  risk metrics under a share policy, in which available power flow depends on demand as well as net demand.

  **Parameters**:
    
  `demand` (`numpy.ndarray`): matrix of demand values where columns are areas and rows are observations.

  `renewables` (`numpy.ndarray`): matrix of renewable generation values where columns are areas and rows are observations

  `gen_dists` (`ConvGenDistribution`, `pd.DataFrame` or `str`): list with information to build conventional generation objects: either the objects themselves, or input to the ConvGenDistribution class constructors
    
  `kwargs` Additional parameters to be passed to ConvGenDistribution constructor, such as column separators.
  &#34;&#34;&#34;

  def __init__(self,demand,renewables,gen_dists,**kwargs):

    self.net_demand = np.ascontiguousarray((demand - renewables),dtype=np.int64).clip(min=0) #no negative net demand
    self.renewables = renewables
    self.demand = np.ascontiguousarray(demand,dtype=np.int64)
    self.gen_dists = self._parse_gendists(gen_dists,**kwargs)
    self.n = self.net_demand.shape[0]

    self.MARGIN_BOUND = int(np.iinfo(np.int64).max / 2)

  def _parse_gendists(self,data,**kwargs):
    gen_dists = []
    for entry in data:
      # if isinstance(entry, str) or isinstance(entry,pd.DataFrame):
      #   print(&#34;Passing to ConvGenDistribution constructor..&#34;)
      #   output = ConvGenDistribution(entry,**kwargs)
      # else:
      #   output = entry
      if isinstance(entry,ConvGenDistribution):
        output = entry
      else:
        print(&#34;Passing to ConvGenDistribution constructor..&#34;)
        output = ConvGenDistribution(entry,**kwargs)
      gen_dists.append(output)
    return gen_dists

  @staticmethod
  def bivar_ecdf(X):
    n = X.shape[0]
    ecdf = np.ascontiguousarray(np.empty((n,)),dtype=np.float64)
    C_CALL.bivar_ecdf(
      ffi.cast(&#34;double *&#34;,ecdf.ctypes.data),
      ffi.cast(&#34;double *&#34;,np.ascontiguousarray(X,dtype=np.float64).ctypes.data),
      np.int64(n))

    return ecdf

  @staticmethod
  def _triangle_prob(bigen, origin,length):
    &#34;&#34;&#34;Recursive calculation of probability mass for the interior of a right, symmetric triangular lattice.
    This function is vestigial from previous package versions and is here only to test it; no method in this class
    uses this function anymore and instead call _trapezoid_prob

    **Parameters**:

    `bigen` (`BivariateConvGenDist`) bivariate available conventional generation object 
    
    `origin` (`list`): right angle coordinate in the plane

    `length` (`int`): length of triangle legs

    &#34;&#34;&#34;
    origin = np.ascontiguousarray(origin,dtype=np.int64)

    return C_CALL.triangle_prob(
                      np.int64(origin[0]),
                      np.int64(origin[1]),
                      np.int64(length),
                      np.int64(bigen.X1.min),
                      np.int64(bigen.X2.min),
                      np.int64(bigen.X1.max),
                      np.int64(bigen.X2.max),
                      ffi.cast(&#34;double *&#34;,bigen.X1.cdf_vals.ctypes.data),
                      ffi.cast(&#34;double *&#34;,bigen.X2.cdf_vals.ctypes.data))


  @staticmethod
  def _is_shortfall_region(m1,m2,c,policy):
    &#34;&#34;&#34;returns true if coordinate is in the shortfall region of area 1 for the given policy

    **Parameters**:
    
    `m1` (`int`): Area 1 margin

    `m2` (`int`): Area 2 margin

    `c` (`int`): Interconnector capacity

    `policy` (`string`): either &#39;share&#39; or &#39;veto&#39;

    &#34;&#34;&#34;
    if policy == &#34;share&#34;:
      return m1 &lt; (c if m2 &lt;= -c else -m2 if abs(m2) &lt;= c else -c)
    elif policy == &#34;veto&#34;:
      return m1 &lt; (0 if m2 &lt;= 0 else -m2 if m2 &lt;= c else -c)
    else:
      raise Exception(&#34;policy not recognised&#34;)

  @staticmethod
  def _get_share_flow(m1,m2,d1,d2,c):
    &#34;&#34;&#34;returns available flow to area 1 under a share policy and given demand and margin values

    **Parameters**:
    
    `m1` (`int`): Area 1 margin

    `m2` (`int`): Area 2 margin

    `d1` (`int`): Demand in area 1

    `d2` (`int`): Demand in area 2

    `c` (`int`): Interconnector capacity

    &#34;&#34;&#34;
    if m1 + m2 &lt; 0 and m1 &lt; c and m2 &lt; c:
      return min(max(float(d1)/(d1+d2)*m2 - float(d2)/(d1+d2)*m1,-c),c)
    else:
      return BivariateHindcastMargin._get_veto_flow(m1,m2,c)

  @staticmethod
  def _get_veto_flow(m1,m2,c):
    &#34;&#34;&#34;returns available flow to area 1 under a veto policy and margin values

    **Parameters**:
    
    `m1` (`int`): Area 1 margin

    `m2` (`int`): Area 2 margin

    `c` (`int`): Interconnector capacity

    &#34;&#34;&#34;
    if m1 &gt; 0 and m2 &lt; 0:
      return -min(c,m1,-m2)
    elif m1 &lt; 0 and m2 &gt; 0:
      return min(c,m2,-m1)
    else:
      return 0

  @staticmethod
  def _get_share_pu(m1,m2,d1,d2,c):
    &#34;&#34;&#34;returns power unserved under a share policy for area 1

    **Parameters**:
    
    `m1` (`int`): Area 1 margin

    `m2` (`int`): Area 2 margin

    `d1` (`int`): Demand in area 1

    `d2` (`int`): Demand in area 2

    `c` (`int`): Interconnector capacity

    &#34;&#34;&#34;

    if not BivariateHindcastMargin._is_shortfall_region(m1,m2,c,&#34;share&#34;):
      return 0
    else:
      return - (m1 + BivariateHindcastMargin._get_share_flow(m1,m2,d1,d2,c))

  @staticmethod
  def _get_veto_pu(m1,m2,c):
    &#34;&#34;&#34;returns power unserved for area 1 under a veto policy

    **Parameters**:
    
    `m1` (`int`): Area 1 margin

    `m2` (`int`): Area 2 margin

    `c` (`int`): Interconnector capacity

    &#34;&#34;&#34;

    if not BivariateHindcastMargin._is_shortfall_region(m1,m2,c,&#34;veto&#34;):
      return 0
    else:
      return - (m1 + BivariateHindcastMargin._get_veto_flow(m1,m2,c))

  def pdf(self,x,**kwargs):
    &#34;&#34;&#34;calculate bivariate PDF

    **Parameters**:
    
    `x` (`numpy.ndarray`): margin values

    `kwargs` : additional arguments to be passed to the CDF function (system parameters like policy)


    &#34;&#34;&#34;

    x = np.int64(x)
    return self.cdf(x,**kwargs) - (self.cdf(x - (1,0),**kwargs) - self.cdf(x - (0,1),**kwargs) + self.cdf(x - (1,1),**kwargs))


  def margin_cdf(self,x,i=0,**kwargs):
    &#34;&#34;&#34;calculate bivariate margin CDF values based on a component index

    **Parameters**:
    
    `x` (`numpy.ndarray`): margin values

    `x` (`numpy.ndarray`): component index

    `kwargs` : additional arguments to be passed to the CDF function (system parameters like policy)


    &#34;&#34;&#34;

    m = (x,self.MARGIN_BOUND) if i == 0 else (self.MARGIN_BOUND,x)
    return self.cdf(m=m,**kwargs)

  # def marginal_cdf(self,x,i=0):

  #   &#34;&#34;&#34;calculate marginal power margin CDF for one of the areas

  #   **Parameters**:
    
  #   *x* (*np.ndarray*): margin values

  #   *i* (*int*): area index

  #   &#34;&#34;&#34;
  #   margin = UnivariateHindcastMargin(self.gen_dists[i],self.net_demand[:,i])
  #   return margin.cdf(x)
    
  # def marginal_pdf(self,x,i=0):

  #   &#34;&#34;&#34;calculate marginal power margin PDF for one of the areas

  #   **Parameters**:
    
  #   *x* (*np.ndarray*): margin values

  #   *i* (*int*): area index

  #   &#34;&#34;&#34;

  #  return self.marginal_cdf(x,i) - self.marginal_cdf(x-1,i)

  def _swap_axes(self):
    &#34;&#34;&#34;swap area indices

    &#34;&#34;&#34;

    self.demand = np.flip(self.demand,axis=1)
    self.net_demand = np.flip(self.net_demand,axis=1)
    self.gen_dists = [self.gen_dists[1],self.gen_dists[0]]
    #self.gen_dists = self.gen_dists[::-1]

  def lole(self,c,policy,axis=0,get_pointwise_risk=False):
    &#34;&#34;&#34;calculate LOLE for one of the areas

    **Parameters**:
    
    `c` (`numpy.ndarray`): interconnector capacity

    `policy` (`str`): either &#39;veto&#39; or &#39;share&#39;

    `axis (`int*): area index for which this will be calculated

    `get_pointwise_risk (`bool`): If `True`, returns pandas dataframe with LOLE contributions historic observation

    &#34;&#34;&#34;

    # if axis == 1:
    #   self._swap_axes()

    m = [np.Inf,np.Inf]
    m[axis] = -1
    #m = (-1,np.Inf)
    lolp_vals = self.cdf(m=m,c=c,policy=policy,get_pointwise_risk=get_pointwise_risk) 
    if get_pointwise_risk:
      lole = lolp_vals
    else:
      lole = self.n * lolp_vals

    return lole

    #lole = self._lole(c=c,policy=policy,get_pointwise_risk=get_pointwise_risk)

    # if axis == 1:
    #   self._swap_axes()


  # @deprecated(version=&#34;1.0.0&#34;,reason=&#34;use lole() instead&#34;)
  # def lole(self,c,policy,axis=0,get_pointwise_risk=False):

  #   return self.lole(c,policy,axis,get_pointwise_risk)

  # def _lole(self,c,policy=&#34;share&#34;,get_pointwise_risk=False):
  #   &#34;&#34;&#34;Returns LOLE for area 1

  #   **Parameters**:
    
  #   `dist` (`BivariateHindcastMargin`): bivariate hindcast object

  #   `c` (`int`): Interconnector capacity

  #   `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

  #   `get_pointwise_risk` (`str`): return pandas DataFrame with net demand values and corresponding pointwise risk measurements
  #   &#34;&#34;&#34;
  #   r = self.lolp(c,policy,get_pointwise_risk)
  #   if isinstance(r,pd.DataFrame):
  #     return r
  #   else:
  #     return self.n * r

  # def lolp(self,c,policy=&#34;share&#34;,get_pointwise_risk=False):
  #   &#34;&#34;&#34;Returns LOLP for area 1

  #   **Parameters**:
    
  #   `dist` (`BivariateHindcastMargin`): bivariate hindcast object

  #   `c` (`int`): Interconnector capacity

  #   `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

  #   `get_pointwise_risk` (`str`): return pandas DataFrame with net demand values and corresponding point-wise risk measurements. Does not work for a null interconnection capacity

  #   &#34;&#34;&#34;
  #   m = (-1,np.Inf)
  #   return self.cdf(m=m,c=c,policy=policy,get_pointwise_risk=get_pointwise_risk)  


  def eeu(self,c,policy,axis=0,get_pointwise_risk=False):
    &#34;&#34;&#34;calculate EEU for one of the areas

    **Parameters**:
    
    `c` (`int`): Interconnector capacity

    `policy` (`str`): either &#39;veto&#39; or &#39;share&#39;

    `axis` (`int`): area index for which this will be calculated 

    `get_pointwise_risk (`bool`): If `True`, returns pandas dataframe with EEU contributions for each historic observation

    &#34;&#34;&#34;

    if axis == 1:
      self._swap_axes()
    
    epu_vals = self.epu(c=c,policy=policy,get_pointwise_risk=get_pointwise_risk)

    if axis == 1:
      self._swap_axes()

    if get_pointwise_risk:
      return epu_vals
    else:
      return self.n * epu_vals

    #return epu

  # def _eeu(self,c,policy=&#34;share&#34;,get_pointwise_risk=False):
  #   &#34;&#34;&#34;Returns EEU for area 1

  #   **Parameters**:
    
  #   `dist` (`BivariateHindcastMargin`): bivariate hindcast object

  #   `c` (`int`): Interconnector capacity

  #   `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

  #   `get_pointwise_risk` (`str`): return pandas DataFrame with net demand values and corresponding pointwise risk measurements
  #   &#34;&#34;&#34;
  #   r = self.epu(c,policy,get_pointwise_risk)
  #   if isinstance(r,pd.DataFrame):
  #     return r
  #   else:
  #     return self.n * r

  def epu(self,c,policy=&#34;share&#34;,get_pointwise_risk=False):
    &#34;&#34;&#34;Returns EPU for area 1

    **Parameters**:
    
    `c` (`int`): Interconnector capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    `get_pointwise_risk` (`str`): return pandas DataFrame with EPU for each historic observation

    &#34;&#34;&#34;
    if c &gt; 0 or get_pointwise_risk:
      #self._check_null_fc()
      X1 = self.gen_dists[0]
      X2 = self.gen_dists[1]
      n = self.n

      EPU = 0

      if get_pointwise_risk:
        nd0 = []
        nd1 = []
        pu = []
        
      for i in range(n):
        #print(i)
        v1, v2 = self.net_demand[i,:]
        d1, d2 = self.demand[i,:]
        if policy == &#34;share&#34;:
          point_EPU = self._cond_EPU_share(X1,X2,d1,d2,v1,v2,c)
        else:
          point_EPU = self._cond_EPU_veto(X1,X2,v1,v2,c)

        EPU += point_EPU
        
        if get_pointwise_risk:
          nd0.append(v1)
          nd1.append(v2)
          pu.append(point_EPU)

      if get_pointwise_risk:
        pw_df = pd.DataFrame({&#34;nd0&#34;:nd0,&#34;nd1&#34;:nd1,&#34;value&#34;:pu})
        return pw_df 
      else:
        return EPU/n
        #return self.season_hours * EPU/n


    else:
      # if interconnector capacity is zero, use UnivariateHindcastMargin to compute risks
      # as it does it more efficiently
      margin = UnivariateHindcastMargin(self.gen_dists[0],self.net_demand[:,0])
      return margin.epu()
  


  def system_eeu(self,c,**kwargs):

    &#34;&#34;&#34;calculate system-wide EEU

    **Parameters**:
    
    `c` (`int`): Interconnector capacity

    &#34;&#34;&#34;
    return self.eeu(c,axis=0,**kwargs) + self.eeu(c,axis=1,**kwags)

  def _simulate_net_demand(self,n,seed=None):
    &#34;&#34;&#34;simulate net demand

    **Parameters**:
    
    `n` (`int`): number of samples

    &#34;&#34;&#34;
    if seed is not None:
      np.random.seed(seed)

    return self.net_demand[np.random.choice(range(self.n),size=n),:]

  def efc(self,**kwargs):
    &#34;&#34;&#34;This method calculates the equivalent firm capacity of interconnection for a given power system. It has been deprecated; use the `itc_efc` method instead. When called, this function calls `itc_efc`, passing all arguments along.
    &#34;&#34;&#34;
    warn(&#34;This method is deprecated; use methods itc_efc or convgen_ifc instead.&#34;)
    return self.itc_efc(**kwargs)

  def convgen_efc(self, cap, prob, gen_axis, fc_axis, c,policy,metric=&#34;lole&#34;,axis=0,tol=0.1,**kwargs):
    &#34;&#34;&#34;Returns the amount of firm capacity that needs to be added to area `fc_axis` such that area `axis` has the same risk (as defined by `metric`) than if new conventional generation was installed in `gen_axis`.

    **Parameters**:
    
    `cap` (`int`): maximum available capacity of new generator in MW

    `prob` (`float`): availability probability for the new generator

    `gen_axis` (`int`): Axis to which the new generator will be added

    `fc_axis` (`int`): Area to which firm capacity will be added

    `c` (`int`): interconnection capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    `axis` (`int`): area for which risk will be calculated

    `metric` (`string`): name of the instance&#39;s method that will be used to measure risk. Only &#39;LOLE&#39; and &#39;EEU&#39; are supported

    `tol` (`float`): absolute error tolerance from true target risk value

    &#34;&#34;&#34;
    if not (axis in [0,1]):
      raise Exception(&#34;axis value must be 0 or 1&#34;)

    if not (gen_axis in [0,1]):
      raise Exception(&#34;gen_axis value must be 0 or 1&#34;)

    if not (fc_axis in [0,1]):
      raise Exception(&#34;fc_axis value must be 0 or 1&#34;)

    if prob &gt; 1 or prob &lt; 0:
      raise Exception(&#34;Availability value must be between 0 and 1&#34;)

    other = 1 - gen_axis
    gen_data = self.gen_dists[gen_axis].original_data

    # create augmented conv gen distribution
    new_row = pd.Series([cap,prob],index=[&#34;Capacity&#34;,&#34;Availability&#34;])
    augmented_data = gen_data.append(new_row,ignore_index=True)
    augmented_gen_dist = ConvGenDistribution(augmented_data)

    # create augmented conv gen bivariate distribution and get risk metric in agumented system
    new_bivariate_dist = [0,1] #place holder values
    new_bivariate_dist[gen_axis] = augmented_gen_dist
    new_bivariate_dist[other] = self.gen_dists[other]
    new_margin_dist = BivariateHindcastMargin(self.demand,self.renewables,new_bivariate_dist)
    new_metric_func = getattr(new_margin_dist,metric)
    new_metric_val = new_metric_func(c=c,policy=policy,axis=axis)

    print(&#34;new metric val: {x}&#34;.format(x=new_metric_val))
    ### take original system and add firm capacity until we get new_metric_val
    # define bisection algorithm&#39;s bounds
    if cap &gt;= 0:
      leftmost = 0
      rightmost = cap
    else:
      rightmost = 0
      leftmost = cap

    # clone object to prevent any side effects
    original_bivariate_dist = [ConvGenDistribution(self.gen_dists[area].original_data) for area in range(2)]
    
    # define objective for bisection algorithm
    def find_efc(x):
      # add firm capacity
      original_bivariate_dist[fc_axis] += x
      # create bivariate margin distribution object
      dist = BivariateHindcastMargin(self.demand,self.renewables,original_bivariate_dist)
      metric_func = getattr(dist,metric)
      metric_val = metric_func(c=c,policy=policy,axis=axis)

      # reset firm capacity to 0
      original_bivariate_dist[fc_axis] += (-original_bivariate_dist[fc_axis].fc)

      print(&#34;Adding {x}, getting val {v}&#34;.format(x=x,v=metric_val))
      return metric_val - new_metric_val

    efc, res = bisect(f=find_efc,a=leftmost,b=rightmost,full_output=True,xtol=tol/2,rtol=tol/(2*new_metric_val))
    if not res.converged:
      print(&#34;Warning: EFC estimator did not converge.&#34;)
    #print(&#34;efc:{efc}&#34;.format(efc=efc))
    return int(efc)


  def itc_efc(self,c,policy,metric=&#34;lole&#34;,axis=0,tol=0.1,**kwargs):
    &#34;&#34;&#34;Returns equivalent firm capacity of interconnector in one area

    **Parameters**:
    
    `c` (`int`): interconnection capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    `axis` (`int`): area for which risk will be calculated

    `metric` (`string`): name of the instance&#39;s method that will be used to measure risk

    `tol` (`float`): absolute error tolerance from true target risk value

    &#34;&#34;&#34;
    if not metric in [&#34;lole&#34;,&#34;eeu&#34;]:
      raise Exception(&#34;Only &#39;lole&#39; or &#39;eeu&#39; supported as risk metrics&#34;)
    
    #target value
    with_itc = getattr(self,metric)(c=c,axis=axis,policy=policy,**kwargs)

    def compare_itc_to_fc(k):
      self.gen_dists[axis] += k ## add firm capacity
      univar = UnivariateHindcastMargin(self.gen_dists[axis],self.net_demand[:,axis])
      #risk_metric = getattr(univar,metric)
      without_itc = getattr(univar,metric)()
      #k_fc_risk =  with_itc - without_itc
      self.gen_dists[axis] += (-k) #reset firm capacity to 0
      return with_itc - without_itc

    diff_to_null = compare_itc_to_fc(0)

    # now find the root of compare_itc_to_fc by bisection

    # is the interconnector adding risk?
    if diff_to_null == 0: #itc is equivalent to null interconnection riskwise
      return 0.0
    else:
      # find suitalbe search intervals that are reasonably small
      if diff_to_null &gt; 0: #interconnector adds risk =&gt; negative firm capacity
        rightmost = 0
        leftmost = -c
        while compare_itc_to_fc(leftmost) &gt; 0 :
          leftmost -= c
      else:
        leftmost = 0
        rightmost = c
        while compare_itc_to_fc(rightmost) &lt; 0:
          rightmost += c
      
      #print(&#34;finding efc in [{a},{b}]&#34;.format(a=leftmost,b=rightmost))
      efc, res = bisect(f=compare_itc_to_fc,a=leftmost,b=rightmost,full_output=True,xtol=tol/2,rtol=tol/(2*with_itc))
      if not res.converged:
        print(&#34;Warning: EFC estimator did not converge.&#34;)
      #print(&#34;efc:{efc}&#34;.format(efc=efc))
      return int(efc)

  def _trapezoid_prob(self,X,ulc,c):

    &#34;&#34;&#34;Compute the probability mass of a trapezoidal segment of the plane
    # The trapezoid os formed by stacking a right triangle on top of a rectangle
    # where the hypotenuse is facing to the right

    **Parameters**:

    `X` (`BivariateConvGenDist`) bivariate available conventional generation object 
    
    `ulc` (`list`): upper left corner

    `c` (`int`): width of trapezoid

    &#34;&#34;&#34;
    return C_CALL.trapezoid_prob(
                        np.int64(ulc1),
                        np.int64(ulc2),
                        np.int64(c),
                        np.int64(X.X1.min),
                        np.int64(X.X2.min),
                        np.int64(X.X1.max),
                        np.int64(X.X2.max),
                        ffi.cast(&#34;double *&#34;,X.X1.cdf_vals.ctypes.data),
                        ffi.cast(&#34;double *&#34;,X.X2.cdf_vals.ctypes.data))

  def _cond_EPU_share(self,FX1,FX2,d1,d2,v1,v2,c):
    &#34;&#34;&#34;Returns EPU conditional on given demand and wind generations under a share policy

    **Parameters**:
    
    `FX1` (`ConvGenDistribution`): available conventional generation distribution object for area 1

    `FX2` (`ConvGenDistribution`): available conventional generation distribution object for area 2

    `d1` (`int`): demand in area 1

    `d2` (`int`): demand in area 2

    `v1` (`int`): net demand in area 1 (demand - renewable generation)

    `v2` (`int`): net demand in area 2

    `c` (`int`): Interconnector capacity

    &#34;&#34;&#34;

    return C_CALL.cond_epu_share(
                    np.int64(d1),
                    np.int64(d2),
                    np.int64(v1),
                    np.int64(v2),
                    np.int64(c),
                    np.int64(FX1.min),
                    np.int64(FX2.min),
                    np.int64(FX1.max),
                    np.int64(FX2.max),
                    ffi.cast(&#34;double *&#34;,FX1.cdf_vals.ctypes.data),
                    ffi.cast(&#34;double *&#34;,FX2.cdf_vals.ctypes.data),
                    ffi.cast(&#34;double *&#34;,FX1.expectation_vals.ctypes.data))
  
  def _cond_EPU_veto(self,FX1,FX2,v1,v2,c):
    &#34;&#34;&#34;Returns EPU conditional on given demand and wind generations under a veto policy

    **Parameters**:
    
    `FX1` (`ConvGenDistribution`): available conventional generation distribution object for area 1

    `FX2` (`ConvGenDistribution`): available conventional generation distribution object for area 2

    `v1` (`int`): net demand in area 1 (demand - renewable generation)

    `v2` (`int`): net demand in area 2

    `c` (`int`): Interconnector capacity

    &#34;&#34;&#34;

    return C_CALL.cond_epu_veto(
                    np.int64(v1),
                    np.int64(v2),
                    np.int64(c),
                    np.int64(FX1.min),
                    np.int64(FX2.min),
                    np.int64(FX1.max),
                    np.int64(FX2.max),
                    ffi.cast(&#34;double *&#34;,FX1.cdf_vals.ctypes.data),
                    ffi.cast(&#34;double *&#34;,FX2.cdf_vals.ctypes.data),
                    ffi.cast(&#34;double *&#34;,FX1.expectation_vals.ctypes.data))
  
  def _check_null_fc(self):
    if np.any([d.fc != 0 for d in self.gen_dists] + [d.min != 0 for d in self.gen_dists]):
        raise Exception(&#34;Bivariate calculations do not support non-zero firm capacity&#34;)

  def simulate_region(self,n,m,c,policy,intersection=True,seed=1):
    &#34;&#34;&#34; Simulate region of post interconnector power margins

    **Parameters**:
    
    `n` (`int`): number of simulations

    `m` (`tuple`): Upper bound that delimits the region for each component

    `c` (`tuple`): Interconnection capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    `intersection` (`bool`): if `True`, simulate from region given by `m[0] &lt;= m_0 AND m[1] &lt;= m_1` inequality; otherwise from region `m[0] &lt;= m_0 OR m[1] &lt;= m_1`

    `seed` (`int`): random seed
    &#34;&#34;&#34;

    def get_prob_df(m,c,policy,intersection):
      if intersection:
        df = self.cdf(m=m,c=c,policy=policy,get_pointwise_risk=True)
      else:
        if m[0] &gt;= self.MARGIN_BOUND or m[1] &gt;= self.MARGIN_BOUND:
          # the union of anything with constraint &lt;= infinity is the whole plane
          df = self.cdf(m=(self.MARGIN_BOUND,self.MARGIN_BOUND),c=c,policy=policy,get_pointwise_risk=True)
        else:
          df1 = self.cdf(m=(self.MARGIN_BOUND,m[1]),c=c,policy=policy,get_pointwise_risk=True)
          df2 = self.cdf(m=(m[0],self.MARGIN_BOUND),c=c,policy=policy,get_pointwise_risk=True)
          df3 = self.cdf(m=m,c=c,policy=policy,get_pointwise_risk=True)
          union_prob = df1[&#34;value&#34;] + df2[&#34;value&#34;] - df3[&#34;value&#34;]
          df = pd.DataFrame({&#34;value&#34;: union_prob,&#34;nd0&#34;:df3[&#34;nd0&#34;],&#34;nd1&#34;:df3[&#34;nd1&#34;]})

      df[&#34;d0&#34;] = self.demand[:,0]
      df[&#34;d1&#34;] = self.demand[:,1]
      df = df.sort_values(by=&#34;value&#34;,ascending=True)#.query(&#34;value &gt;= 0&#34;) #sometimes rounding errors may 
      # produce negative probabilities in the order of -1e-60
      #print(df)
      return df

    np.random.seed(seed)

    m = np.clip(m,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
    m1, m2 = m

    X1 = self.gen_dists[0]
    X2 = self.gen_dists[1]

    X = BivariateConvGenDist(X1,X2) #system-wide conv. gen. distribution

    simulated = np.ascontiguousarray(np.zeros((n,2)),dtype=np.int64)

    ### calculate conditional probability of each historical observation given
    ### margin value tuple m
    df = get_prob_df(m=m,c=c,policy=policy,intersection=intersection)
    probs = df[&#34;value&#34;]
    total_prob = np.sum(probs)
    if total_prob &lt;= 1e-8:
      raise Exception(&#34;Region has probability lower than 1e-8; too small to simulate accurately&#34;)
    else:
      probs = np.array(probs)/total_prob
      
      df[&#34;row_weights&#34;] = np.random.multinomial(n=n,pvals=probs,size=1).reshape((df.shape[0],))
      ## only pass rows which induce at least one simulated value
      df = df.query(&#34;row_weights &gt; 0&#34;)

      row_weights = np.ascontiguousarray(df[&#34;row_weights&#34;],dtype=np.int64)

      net_demand = np.ascontiguousarray(df[[&#34;nd0&#34;,&#34;nd1&#34;]],dtype=np.int64)

      demand = np.ascontiguousarray(df[[&#34;d0&#34;,&#34;d1&#34;]],dtype=np.int64)

      C_CALL.region_simulation(
        np.int64(n),
        ffi.cast(&#34;long *&#34;,simulated.ctypes.data),
        np.int64(X.X1.min),
        np.int64(X.X2.min),
        np.int64(X.X1.max),
        np.int64(X.X2.max),
        ffi.cast(&#34;double *&#34;,X.X1.cdf_vals.ctypes.data),
        ffi.cast(&#34;double *&#34;,X.X2.cdf_vals.ctypes.data),
        ffi.cast(&#34;long *&#34;,net_demand.ctypes.data),
        ffi.cast(&#34;long *&#34;,demand.ctypes.data),
        ffi.cast(&#34;long *&#34;,row_weights.ctypes.data),
        np.int64(net_demand.shape[0]),
        np.int64(m1),
        np.int64(m2),
        np.int64(c),
        int(seed),
        int(intersection),
        int(policy == &#34;share&#34;))

      return simulated

  def simulate_conditional(self,n,cond_value,cond_axis,c,policy,seed=1):
    &#34;&#34;&#34; Simulate power margins in one area conditioned to a particular value in the other area

    **Parameters**:
    
    `n` (`int`): number of simulated values

    `cond_value` (`int`): conditioning power margin value

    `cond_axis` (`int`): Conditioning component

    `c` (`tuple`): Interconnection capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    `seed` (`int`): random seed
    &#34;&#34;&#34;

    np.random.seed(seed)
    m1 = np.clip(cond_value,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
    m2 = self.MARGIN_BOUND

    if cond_axis == 1:
      self._swap_axes()

    X1 = self.gen_dists[0]
    X2 = self.gen_dists[1]

    X = BivariateConvGenDist(X1,X2) #system-wide conv. gen. distribution

    simulated = np.ascontiguousarray(np.zeros((n,2)),dtype=np.int64)

    ### calculate conditional probability of each historical observation given
    ### margin value tuple m
    df = self.cdf(m=(m1,m2),c=c,policy=policy,get_pointwise_risk=True)    
    df[&#34;value&#34;] = df[&#34;value&#34;] - self.cdf(m=(m1-1,m2),c=c,policy=policy,get_pointwise_risk=True)[&#34;value&#34;]

    df[&#34;d0&#34;] = self.demand[:,0]
    df[&#34;d1&#34;] = self.demand[:,1]

    ## rounding errors can make probabilities negative of the order of 1e-60
    df = df.query(&#34;value &gt; 0&#34;)
    df = df.sort_values(by=&#34;value&#34;,ascending=True)
    probs = df[&#34;value&#34;]
    total_prob = np.sum(probs)
    
    if total_prob &lt;= 1e-8:
      raise Exception(&#34;Region has probability lower than 1e-8; too small to simulate accurately&#34;)
    else:
      probs = np.array(probs)/total_prob
      
      df[&#34;row_weights&#34;] = np.random.multinomial(n=n,pvals=probs,size=1).reshape((df.shape[0],))
      ## only pass rows which induce at least one simulated value
      df = df.query(&#34;row_weights &gt; 0&#34;)

      row_weights = np.ascontiguousarray(df[&#34;row_weights&#34;],dtype=np.int64)

      net_demand = np.ascontiguousarray(df[[&#34;nd0&#34;,&#34;nd1&#34;]],dtype=np.int64)

      demand = np.ascontiguousarray(df[[&#34;d0&#34;,&#34;d1&#34;]],dtype=np.int64)

      C_CALL.conditioned_simulation(
          np.int64(n),
          ffi.cast(&#34;long *&#34;,simulated.ctypes.data),
          np.int64(X.X1.min),
          np.int64(X.X2.min),
          np.int64(X.X1.max),
          np.int64(X.X2.max),
          ffi.cast(&#34;double *&#34;,X.X1.cdf_vals.ctypes.data),
          ffi.cast(&#34;double *&#34;,X.X2.cdf_vals.ctypes.data),
          ffi.cast(&#34;long *&#34;,net_demand.ctypes.data),
          ffi.cast(&#34;long *&#34;,demand.ctypes.data),
          ffi.cast(&#34;long *&#34;,row_weights.ctypes.data),
          np.int64(net_demand.shape[0]),
          np.int64(m1),
          np.int64(c),
          int(seed),
          int(policy == &#34;share&#34;))

    if cond_axis == 1:
      self._swap_axes()

    return simulated[:,1] #first column has variable conditioned on (constant value)

  def cdf(self,m,c=0,policy=&#34;share&#34;,get_pointwise_risk=False):

    &#34;&#34;&#34;Evaluate the CDF of bivariate power margins for a given system configuration under hindcast.

    **Parameters**:
    
    `m` (`tuple`, `list`, or `numpy.ndarray`) point to evaluate in power margin space

    `c` (`int`): Interconnector capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    `get_pointwise_risk` (`str`): return pandas DataFrame with shortfall probabilities induced by each historic observation

    &#34;&#34;&#34;

    m = np.clip(m,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
    m1, m2 = m
    #self._check_null_fc()

    gendist1, gendist2 = self.gen_dists
    #X2 = self.gen_dists[1]

    #X = BivariateConvGenDist(X1,X2) #system-wide conv. gen. distribution
   
    n = self.n

    cdf = 0

    if get_pointwise_risk:
      nd0 = []
      nd1 = []
      cdf_list = []
      
    for i in range(n):
      #print(i)
      v1, v2 = self.net_demand[i,:]

      d1, d2 = self.demand[i,:]

      point_cdf = C_CALL.get_cond_cdf(
                      np.int64(gendist1.min),
                      np.int64(gendist2.min),
                      np.int64(gendist1.max),
                      np.int64(gendist2.max),
                      ffi.cast(&#34;double *&#34;,gendist1.cdf_vals.ctypes.data),
                      ffi.cast(&#34;double *&#34;,gendist2.cdf_vals.ctypes.data),
                      np.int64(m1),
                      np.int64(m2),
                      np.int64(v1),
                      np.int64(v2),
                      np.int64(d1),
                      np.int64(d2),
                      np.int64(c),
                      np.int64(policy == &#34;share&#34;))

      #print(&#34;point cdf: {x}, index: {i}&#34;.format(x=point_cdf, i=i))
      cdf += point_cdf

      #print(v1)
      if get_pointwise_risk:
          nd0.append(v1)
          nd1.append(v2)
          cdf_list.append(point_cdf)

    if get_pointwise_risk:
      pw_df = pd.DataFrame({&#34;nd0&#34;:nd0,&#34;nd1&#34;:nd1,&#34;value&#34;:cdf_list})
      #print(pw_df)
      return pw_df
    else:   
      return cdf/n

    # else:
    #   # if interconnector capacity is zero, use UnivariateHindcastMargin to compute risks
    #   # as it does it more efficiently
    #   margin = UnivariateHindcastMargin(self.gen_dists[0],self.net_demand[:,0])
    #   return margin.lolp()

  def system_lolp(self,c,get_pointwise_risk=False):
    &#34;&#34;&#34;Returns system-wise LOLP

    **Parameters**:
    
    `c` (`int`): Interconnector capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    `get_pointwise_risk` (`str`): return pandas DataFrame with LOLPs for each historic observation

    &#34;&#34;&#34;

    # calculate LOLP
    X1 = self.gen_dists[0]
    X2 = self.gen_dists[1]

    X = BivariateConvGenDist(X1,X2) #system-wide conv. gen. distribution
    
    n = self.n

    LOLP = 0

    if get_pointwise_risk:
      nd0 = []
      nd1 = []
      lolp = []
      
    for i in range(n):
      #print(i)
      v1, v2 = self.net_demand[i,:]
      # system-wide LOLP does not depend on the policy
      #point_LOLP = X.cdf((v1-c-1,math.inf)) + X.cdf((math.inf,v2-c-1)) - X.cdf((v1-c-1,v2-c-1)) + BivariateHindcastMargin._triangle_prob(X,(v1-c-1,v2-c-1),2*c+1)
      point_LOLP = X.cdf((v1-c-1,math.inf)) + X.cdf((math.inf,v2-c-1)) - X.cdf((v1+c,v2-c-1)) + self._trapezoid_prob(X,(v1-c-1,v2+c),2*c)
      LOLP += point_LOLP

      if get_pointwise_risk:
        nd0.append(v1)
        nd1.append(v2)
        lolp.append(point_LOLP)

    if get_pointwise_risk:
      pw_df = pd.DataFrame({&#34;nd0&#34;:nd0,&#34;nd1&#34;:nd1,&#34;value&#34;:lolp})
      return pw_df
    else:    
      return LOLP/n

  def _simulate_conditional_demand_ratio(self,n,cond_value,cond_axis,c,policy,seed=1):

    np.random.seed(seed)
    m1 = np.clip(cond_value,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
    m2 = self.MARGIN_BOUND

    if cond_axis == 1:
      self._swap_axes()

    ### calculate conditional probability of each historical observation given
    ### margin value tuple m
    df = self.cdf(m=(m1,m2),c=c,policy=policy,get_pointwise_risk=True)    
    #df[&#34;value&#34;] = df[&#34;value&#34;] - self.cdf(m=(m1-1,m2),c=c,policy=policy,get_pointwise_risk=True)[&#34;value&#34;]

    df[&#34;d0&#34;] = self.demand[:,0]
    df[&#34;d1&#34;] = self.demand[:,1]

    ## rounding errors can make probabilities negative of the order of 1e-60
    df = df.query(&#34;value &gt; 0&#34;)
    df = df.sort_values(by=&#34;value&#34;,ascending=True)
    probs = df[&#34;value&#34;]
    total_prob = np.sum(probs)
    
    if total_prob &lt;= 1e-8:
      raise Exception(&#34;Region has probability lower than 1e-8; too small to simulate accurately&#34;)
    else:
      probs = np.array(probs)/total_prob
      
      sample_indices = np.random.choice(range(df.shape[0]),size=n,replace=True,p=probs)
      d0 = np.array(df[&#34;d0&#34;])[sample_indices]
      d1 = np.array(df[&#34;d1&#34;])[sample_indices]

      return d0/(d0 + d1)


  def system_lole(self,c,get_pointwise_risk=False):
    &#34;&#34;&#34;Returns system-wise LOLE

    **Parameters**:
    
    `c` (`int`): Interconnector capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    `get_pointwise_risk` (`str`): return pandas DataFrame with system LOLE contributions for each historic observation
    &#34;&#34;&#34;
    return self.n * self.system_lolp(c,get_pointwise_risk)


  def margin_quantile(self,q,i=0,c=0,policy=&#34;veto&#34;):

    &#34;&#34;&#34;Returns quantile of any of the margin distributions

    **Parameters**:
    
    `q` (`float`): quantile

    `i (`int*): area index for which this will be calculated

    `c` (`int`): Interconnector capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    &#34;&#34;&#34;
    def bisection(x):
      y = np.empty((2,))
      y[1-i] = np.Inf
      y[i] = x
      return self.cdf(y,c=c,policy=policy) - q
    
    step = 1000

    lower = 0
    upper = 0

    while bisection(lower) &gt;= 0:
      lower -= step

    while bisection(upper) &lt;= 0:
      upper += step

    return bisect(f=bisection,a=lower,b=upper)

  # def gen_efc(self,c,policy,metric=&#34;LOLE&#34;,axis=0,**kwargs):
  #   &#34;&#34;&#34;Returns equivalent firm capacity of interconnector in one area

  #   **Parameters**:
    
  #   *c* (*int*): interconnection capacity

  #   *policy* (*str*): Either &#39;share&#39; or &#39;veto&#39;

  #   *axis* (*int*): area for which this will be calculated

  #   *metric* (*string*): name of the instance&#39;s method that will be used to measure risk

  #   &#34;&#34;&#34;
  #   if not metric in [&#34;LOLE&#34;,&#34;EEU&#34;]:
  #     raise Exception(&#34;Only LOLE or EPU supported as risk metrics&#34;)
    
  #   with_itc = getattr(self,metric)(c=c,axis=axis,policy=policy,**kwargs)
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin"><code class="flex name class">
<span>class <span class="ident">BivariateHindcastMargin</span></span>
<span>(</span><span>demand, renewables, gen_dists, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Main class for risk calculations in a time-collapsed 2-area hindcast model.
It receives demand and wind generation data as opposed to just net demand data, to make it posible to calculate
risk metrics under a share policy, in which available power flow depends on demand as well as net demand.</p>
<p><strong>Parameters</strong>:</p>
<p><code>demand</code> (<code>numpy.ndarray</code>): matrix of demand values where columns are areas and rows are observations.</p>
<p><code>renewables</code> (<code>numpy.ndarray</code>): matrix of renewable generation values where columns are areas and rows are observations</p>
<p><code>gen_dists</code> (<code>ConvGenDistribution</code>, <code>pd.DataFrame</code> or <code>str</code>): list with information to build conventional generation objects: either the objects themselves, or input to the ConvGenDistribution class constructors</p>
<p><code>kwargs</code> Additional parameters to be passed to ConvGenDistribution constructor, such as column separators.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BivariateHindcastMargin(object):
  &#34;&#34;&#34;Main class for risk calculations in a time-collapsed 2-area hindcast model.
  It receives demand and wind generation data as opposed to just net demand data, to make it posible to calculate
  risk metrics under a share policy, in which available power flow depends on demand as well as net demand.

  **Parameters**:
    
  `demand` (`numpy.ndarray`): matrix of demand values where columns are areas and rows are observations.

  `renewables` (`numpy.ndarray`): matrix of renewable generation values where columns are areas and rows are observations

  `gen_dists` (`ConvGenDistribution`, `pd.DataFrame` or `str`): list with information to build conventional generation objects: either the objects themselves, or input to the ConvGenDistribution class constructors
    
  `kwargs` Additional parameters to be passed to ConvGenDistribution constructor, such as column separators.
  &#34;&#34;&#34;

  def __init__(self,demand,renewables,gen_dists,**kwargs):

    self.net_demand = np.ascontiguousarray((demand - renewables),dtype=np.int64).clip(min=0) #no negative net demand
    self.renewables = renewables
    self.demand = np.ascontiguousarray(demand,dtype=np.int64)
    self.gen_dists = self._parse_gendists(gen_dists,**kwargs)
    self.n = self.net_demand.shape[0]

    self.MARGIN_BOUND = int(np.iinfo(np.int64).max / 2)

  def _parse_gendists(self,data,**kwargs):
    gen_dists = []
    for entry in data:
      # if isinstance(entry, str) or isinstance(entry,pd.DataFrame):
      #   print(&#34;Passing to ConvGenDistribution constructor..&#34;)
      #   output = ConvGenDistribution(entry,**kwargs)
      # else:
      #   output = entry
      if isinstance(entry,ConvGenDistribution):
        output = entry
      else:
        print(&#34;Passing to ConvGenDistribution constructor..&#34;)
        output = ConvGenDistribution(entry,**kwargs)
      gen_dists.append(output)
    return gen_dists

  @staticmethod
  def bivar_ecdf(X):
    n = X.shape[0]
    ecdf = np.ascontiguousarray(np.empty((n,)),dtype=np.float64)
    C_CALL.bivar_ecdf(
      ffi.cast(&#34;double *&#34;,ecdf.ctypes.data),
      ffi.cast(&#34;double *&#34;,np.ascontiguousarray(X,dtype=np.float64).ctypes.data),
      np.int64(n))

    return ecdf

  @staticmethod
  def _triangle_prob(bigen, origin,length):
    &#34;&#34;&#34;Recursive calculation of probability mass for the interior of a right, symmetric triangular lattice.
    This function is vestigial from previous package versions and is here only to test it; no method in this class
    uses this function anymore and instead call _trapezoid_prob

    **Parameters**:

    `bigen` (`BivariateConvGenDist`) bivariate available conventional generation object 
    
    `origin` (`list`): right angle coordinate in the plane

    `length` (`int`): length of triangle legs

    &#34;&#34;&#34;
    origin = np.ascontiguousarray(origin,dtype=np.int64)

    return C_CALL.triangle_prob(
                      np.int64(origin[0]),
                      np.int64(origin[1]),
                      np.int64(length),
                      np.int64(bigen.X1.min),
                      np.int64(bigen.X2.min),
                      np.int64(bigen.X1.max),
                      np.int64(bigen.X2.max),
                      ffi.cast(&#34;double *&#34;,bigen.X1.cdf_vals.ctypes.data),
                      ffi.cast(&#34;double *&#34;,bigen.X2.cdf_vals.ctypes.data))


  @staticmethod
  def _is_shortfall_region(m1,m2,c,policy):
    &#34;&#34;&#34;returns true if coordinate is in the shortfall region of area 1 for the given policy

    **Parameters**:
    
    `m1` (`int`): Area 1 margin

    `m2` (`int`): Area 2 margin

    `c` (`int`): Interconnector capacity

    `policy` (`string`): either &#39;share&#39; or &#39;veto&#39;

    &#34;&#34;&#34;
    if policy == &#34;share&#34;:
      return m1 &lt; (c if m2 &lt;= -c else -m2 if abs(m2) &lt;= c else -c)
    elif policy == &#34;veto&#34;:
      return m1 &lt; (0 if m2 &lt;= 0 else -m2 if m2 &lt;= c else -c)
    else:
      raise Exception(&#34;policy not recognised&#34;)

  @staticmethod
  def _get_share_flow(m1,m2,d1,d2,c):
    &#34;&#34;&#34;returns available flow to area 1 under a share policy and given demand and margin values

    **Parameters**:
    
    `m1` (`int`): Area 1 margin

    `m2` (`int`): Area 2 margin

    `d1` (`int`): Demand in area 1

    `d2` (`int`): Demand in area 2

    `c` (`int`): Interconnector capacity

    &#34;&#34;&#34;
    if m1 + m2 &lt; 0 and m1 &lt; c and m2 &lt; c:
      return min(max(float(d1)/(d1+d2)*m2 - float(d2)/(d1+d2)*m1,-c),c)
    else:
      return BivariateHindcastMargin._get_veto_flow(m1,m2,c)

  @staticmethod
  def _get_veto_flow(m1,m2,c):
    &#34;&#34;&#34;returns available flow to area 1 under a veto policy and margin values

    **Parameters**:
    
    `m1` (`int`): Area 1 margin

    `m2` (`int`): Area 2 margin

    `c` (`int`): Interconnector capacity

    &#34;&#34;&#34;
    if m1 &gt; 0 and m2 &lt; 0:
      return -min(c,m1,-m2)
    elif m1 &lt; 0 and m2 &gt; 0:
      return min(c,m2,-m1)
    else:
      return 0

  @staticmethod
  def _get_share_pu(m1,m2,d1,d2,c):
    &#34;&#34;&#34;returns power unserved under a share policy for area 1

    **Parameters**:
    
    `m1` (`int`): Area 1 margin

    `m2` (`int`): Area 2 margin

    `d1` (`int`): Demand in area 1

    `d2` (`int`): Demand in area 2

    `c` (`int`): Interconnector capacity

    &#34;&#34;&#34;

    if not BivariateHindcastMargin._is_shortfall_region(m1,m2,c,&#34;share&#34;):
      return 0
    else:
      return - (m1 + BivariateHindcastMargin._get_share_flow(m1,m2,d1,d2,c))

  @staticmethod
  def _get_veto_pu(m1,m2,c):
    &#34;&#34;&#34;returns power unserved for area 1 under a veto policy

    **Parameters**:
    
    `m1` (`int`): Area 1 margin

    `m2` (`int`): Area 2 margin

    `c` (`int`): Interconnector capacity

    &#34;&#34;&#34;

    if not BivariateHindcastMargin._is_shortfall_region(m1,m2,c,&#34;veto&#34;):
      return 0
    else:
      return - (m1 + BivariateHindcastMargin._get_veto_flow(m1,m2,c))

  def pdf(self,x,**kwargs):
    &#34;&#34;&#34;calculate bivariate PDF

    **Parameters**:
    
    `x` (`numpy.ndarray`): margin values

    `kwargs` : additional arguments to be passed to the CDF function (system parameters like policy)


    &#34;&#34;&#34;

    x = np.int64(x)
    return self.cdf(x,**kwargs) - (self.cdf(x - (1,0),**kwargs) - self.cdf(x - (0,1),**kwargs) + self.cdf(x - (1,1),**kwargs))


  def margin_cdf(self,x,i=0,**kwargs):
    &#34;&#34;&#34;calculate bivariate margin CDF values based on a component index

    **Parameters**:
    
    `x` (`numpy.ndarray`): margin values

    `x` (`numpy.ndarray`): component index

    `kwargs` : additional arguments to be passed to the CDF function (system parameters like policy)


    &#34;&#34;&#34;

    m = (x,self.MARGIN_BOUND) if i == 0 else (self.MARGIN_BOUND,x)
    return self.cdf(m=m,**kwargs)

  # def marginal_cdf(self,x,i=0):

  #   &#34;&#34;&#34;calculate marginal power margin CDF for one of the areas

  #   **Parameters**:
    
  #   *x* (*np.ndarray*): margin values

  #   *i* (*int*): area index

  #   &#34;&#34;&#34;
  #   margin = UnivariateHindcastMargin(self.gen_dists[i],self.net_demand[:,i])
  #   return margin.cdf(x)
    
  # def marginal_pdf(self,x,i=0):

  #   &#34;&#34;&#34;calculate marginal power margin PDF for one of the areas

  #   **Parameters**:
    
  #   *x* (*np.ndarray*): margin values

  #   *i* (*int*): area index

  #   &#34;&#34;&#34;

  #  return self.marginal_cdf(x,i) - self.marginal_cdf(x-1,i)

  def _swap_axes(self):
    &#34;&#34;&#34;swap area indices

    &#34;&#34;&#34;

    self.demand = np.flip(self.demand,axis=1)
    self.net_demand = np.flip(self.net_demand,axis=1)
    self.gen_dists = [self.gen_dists[1],self.gen_dists[0]]
    #self.gen_dists = self.gen_dists[::-1]

  def lole(self,c,policy,axis=0,get_pointwise_risk=False):
    &#34;&#34;&#34;calculate LOLE for one of the areas

    **Parameters**:
    
    `c` (`numpy.ndarray`): interconnector capacity

    `policy` (`str`): either &#39;veto&#39; or &#39;share&#39;

    `axis (`int*): area index for which this will be calculated

    `get_pointwise_risk (`bool`): If `True`, returns pandas dataframe with LOLE contributions historic observation

    &#34;&#34;&#34;

    # if axis == 1:
    #   self._swap_axes()

    m = [np.Inf,np.Inf]
    m[axis] = -1
    #m = (-1,np.Inf)
    lolp_vals = self.cdf(m=m,c=c,policy=policy,get_pointwise_risk=get_pointwise_risk) 
    if get_pointwise_risk:
      lole = lolp_vals
    else:
      lole = self.n * lolp_vals

    return lole

    #lole = self._lole(c=c,policy=policy,get_pointwise_risk=get_pointwise_risk)

    # if axis == 1:
    #   self._swap_axes()


  # @deprecated(version=&#34;1.0.0&#34;,reason=&#34;use lole() instead&#34;)
  # def lole(self,c,policy,axis=0,get_pointwise_risk=False):

  #   return self.lole(c,policy,axis,get_pointwise_risk)

  # def _lole(self,c,policy=&#34;share&#34;,get_pointwise_risk=False):
  #   &#34;&#34;&#34;Returns LOLE for area 1

  #   **Parameters**:
    
  #   `dist` (`BivariateHindcastMargin`): bivariate hindcast object

  #   `c` (`int`): Interconnector capacity

  #   `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

  #   `get_pointwise_risk` (`str`): return pandas DataFrame with net demand values and corresponding pointwise risk measurements
  #   &#34;&#34;&#34;
  #   r = self.lolp(c,policy,get_pointwise_risk)
  #   if isinstance(r,pd.DataFrame):
  #     return r
  #   else:
  #     return self.n * r

  # def lolp(self,c,policy=&#34;share&#34;,get_pointwise_risk=False):
  #   &#34;&#34;&#34;Returns LOLP for area 1

  #   **Parameters**:
    
  #   `dist` (`BivariateHindcastMargin`): bivariate hindcast object

  #   `c` (`int`): Interconnector capacity

  #   `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

  #   `get_pointwise_risk` (`str`): return pandas DataFrame with net demand values and corresponding point-wise risk measurements. Does not work for a null interconnection capacity

  #   &#34;&#34;&#34;
  #   m = (-1,np.Inf)
  #   return self.cdf(m=m,c=c,policy=policy,get_pointwise_risk=get_pointwise_risk)  


  def eeu(self,c,policy,axis=0,get_pointwise_risk=False):
    &#34;&#34;&#34;calculate EEU for one of the areas

    **Parameters**:
    
    `c` (`int`): Interconnector capacity

    `policy` (`str`): either &#39;veto&#39; or &#39;share&#39;

    `axis` (`int`): area index for which this will be calculated 

    `get_pointwise_risk (`bool`): If `True`, returns pandas dataframe with EEU contributions for each historic observation

    &#34;&#34;&#34;

    if axis == 1:
      self._swap_axes()
    
    epu_vals = self.epu(c=c,policy=policy,get_pointwise_risk=get_pointwise_risk)

    if axis == 1:
      self._swap_axes()

    if get_pointwise_risk:
      return epu_vals
    else:
      return self.n * epu_vals

    #return epu

  # def _eeu(self,c,policy=&#34;share&#34;,get_pointwise_risk=False):
  #   &#34;&#34;&#34;Returns EEU for area 1

  #   **Parameters**:
    
  #   `dist` (`BivariateHindcastMargin`): bivariate hindcast object

  #   `c` (`int`): Interconnector capacity

  #   `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

  #   `get_pointwise_risk` (`str`): return pandas DataFrame with net demand values and corresponding pointwise risk measurements
  #   &#34;&#34;&#34;
  #   r = self.epu(c,policy,get_pointwise_risk)
  #   if isinstance(r,pd.DataFrame):
  #     return r
  #   else:
  #     return self.n * r

  def epu(self,c,policy=&#34;share&#34;,get_pointwise_risk=False):
    &#34;&#34;&#34;Returns EPU for area 1

    **Parameters**:
    
    `c` (`int`): Interconnector capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    `get_pointwise_risk` (`str`): return pandas DataFrame with EPU for each historic observation

    &#34;&#34;&#34;
    if c &gt; 0 or get_pointwise_risk:
      #self._check_null_fc()
      X1 = self.gen_dists[0]
      X2 = self.gen_dists[1]
      n = self.n

      EPU = 0

      if get_pointwise_risk:
        nd0 = []
        nd1 = []
        pu = []
        
      for i in range(n):
        #print(i)
        v1, v2 = self.net_demand[i,:]
        d1, d2 = self.demand[i,:]
        if policy == &#34;share&#34;:
          point_EPU = self._cond_EPU_share(X1,X2,d1,d2,v1,v2,c)
        else:
          point_EPU = self._cond_EPU_veto(X1,X2,v1,v2,c)

        EPU += point_EPU
        
        if get_pointwise_risk:
          nd0.append(v1)
          nd1.append(v2)
          pu.append(point_EPU)

      if get_pointwise_risk:
        pw_df = pd.DataFrame({&#34;nd0&#34;:nd0,&#34;nd1&#34;:nd1,&#34;value&#34;:pu})
        return pw_df 
      else:
        return EPU/n
        #return self.season_hours * EPU/n


    else:
      # if interconnector capacity is zero, use UnivariateHindcastMargin to compute risks
      # as it does it more efficiently
      margin = UnivariateHindcastMargin(self.gen_dists[0],self.net_demand[:,0])
      return margin.epu()
  


  def system_eeu(self,c,**kwargs):

    &#34;&#34;&#34;calculate system-wide EEU

    **Parameters**:
    
    `c` (`int`): Interconnector capacity

    &#34;&#34;&#34;
    return self.eeu(c,axis=0,**kwargs) + self.eeu(c,axis=1,**kwags)

  def _simulate_net_demand(self,n,seed=None):
    &#34;&#34;&#34;simulate net demand

    **Parameters**:
    
    `n` (`int`): number of samples

    &#34;&#34;&#34;
    if seed is not None:
      np.random.seed(seed)

    return self.net_demand[np.random.choice(range(self.n),size=n),:]

  def efc(self,**kwargs):
    &#34;&#34;&#34;This method calculates the equivalent firm capacity of interconnection for a given power system. It has been deprecated; use the `itc_efc` method instead. When called, this function calls `itc_efc`, passing all arguments along.
    &#34;&#34;&#34;
    warn(&#34;This method is deprecated; use methods itc_efc or convgen_ifc instead.&#34;)
    return self.itc_efc(**kwargs)

  def convgen_efc(self, cap, prob, gen_axis, fc_axis, c,policy,metric=&#34;lole&#34;,axis=0,tol=0.1,**kwargs):
    &#34;&#34;&#34;Returns the amount of firm capacity that needs to be added to area `fc_axis` such that area `axis` has the same risk (as defined by `metric`) than if new conventional generation was installed in `gen_axis`.

    **Parameters**:
    
    `cap` (`int`): maximum available capacity of new generator in MW

    `prob` (`float`): availability probability for the new generator

    `gen_axis` (`int`): Axis to which the new generator will be added

    `fc_axis` (`int`): Area to which firm capacity will be added

    `c` (`int`): interconnection capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    `axis` (`int`): area for which risk will be calculated

    `metric` (`string`): name of the instance&#39;s method that will be used to measure risk. Only &#39;LOLE&#39; and &#39;EEU&#39; are supported

    `tol` (`float`): absolute error tolerance from true target risk value

    &#34;&#34;&#34;
    if not (axis in [0,1]):
      raise Exception(&#34;axis value must be 0 or 1&#34;)

    if not (gen_axis in [0,1]):
      raise Exception(&#34;gen_axis value must be 0 or 1&#34;)

    if not (fc_axis in [0,1]):
      raise Exception(&#34;fc_axis value must be 0 or 1&#34;)

    if prob &gt; 1 or prob &lt; 0:
      raise Exception(&#34;Availability value must be between 0 and 1&#34;)

    other = 1 - gen_axis
    gen_data = self.gen_dists[gen_axis].original_data

    # create augmented conv gen distribution
    new_row = pd.Series([cap,prob],index=[&#34;Capacity&#34;,&#34;Availability&#34;])
    augmented_data = gen_data.append(new_row,ignore_index=True)
    augmented_gen_dist = ConvGenDistribution(augmented_data)

    # create augmented conv gen bivariate distribution and get risk metric in agumented system
    new_bivariate_dist = [0,1] #place holder values
    new_bivariate_dist[gen_axis] = augmented_gen_dist
    new_bivariate_dist[other] = self.gen_dists[other]
    new_margin_dist = BivariateHindcastMargin(self.demand,self.renewables,new_bivariate_dist)
    new_metric_func = getattr(new_margin_dist,metric)
    new_metric_val = new_metric_func(c=c,policy=policy,axis=axis)

    print(&#34;new metric val: {x}&#34;.format(x=new_metric_val))
    ### take original system and add firm capacity until we get new_metric_val
    # define bisection algorithm&#39;s bounds
    if cap &gt;= 0:
      leftmost = 0
      rightmost = cap
    else:
      rightmost = 0
      leftmost = cap

    # clone object to prevent any side effects
    original_bivariate_dist = [ConvGenDistribution(self.gen_dists[area].original_data) for area in range(2)]
    
    # define objective for bisection algorithm
    def find_efc(x):
      # add firm capacity
      original_bivariate_dist[fc_axis] += x
      # create bivariate margin distribution object
      dist = BivariateHindcastMargin(self.demand,self.renewables,original_bivariate_dist)
      metric_func = getattr(dist,metric)
      metric_val = metric_func(c=c,policy=policy,axis=axis)

      # reset firm capacity to 0
      original_bivariate_dist[fc_axis] += (-original_bivariate_dist[fc_axis].fc)

      print(&#34;Adding {x}, getting val {v}&#34;.format(x=x,v=metric_val))
      return metric_val - new_metric_val

    efc, res = bisect(f=find_efc,a=leftmost,b=rightmost,full_output=True,xtol=tol/2,rtol=tol/(2*new_metric_val))
    if not res.converged:
      print(&#34;Warning: EFC estimator did not converge.&#34;)
    #print(&#34;efc:{efc}&#34;.format(efc=efc))
    return int(efc)


  def itc_efc(self,c,policy,metric=&#34;lole&#34;,axis=0,tol=0.1,**kwargs):
    &#34;&#34;&#34;Returns equivalent firm capacity of interconnector in one area

    **Parameters**:
    
    `c` (`int`): interconnection capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    `axis` (`int`): area for which risk will be calculated

    `metric` (`string`): name of the instance&#39;s method that will be used to measure risk

    `tol` (`float`): absolute error tolerance from true target risk value

    &#34;&#34;&#34;
    if not metric in [&#34;lole&#34;,&#34;eeu&#34;]:
      raise Exception(&#34;Only &#39;lole&#39; or &#39;eeu&#39; supported as risk metrics&#34;)
    
    #target value
    with_itc = getattr(self,metric)(c=c,axis=axis,policy=policy,**kwargs)

    def compare_itc_to_fc(k):
      self.gen_dists[axis] += k ## add firm capacity
      univar = UnivariateHindcastMargin(self.gen_dists[axis],self.net_demand[:,axis])
      #risk_metric = getattr(univar,metric)
      without_itc = getattr(univar,metric)()
      #k_fc_risk =  with_itc - without_itc
      self.gen_dists[axis] += (-k) #reset firm capacity to 0
      return with_itc - without_itc

    diff_to_null = compare_itc_to_fc(0)

    # now find the root of compare_itc_to_fc by bisection

    # is the interconnector adding risk?
    if diff_to_null == 0: #itc is equivalent to null interconnection riskwise
      return 0.0
    else:
      # find suitalbe search intervals that are reasonably small
      if diff_to_null &gt; 0: #interconnector adds risk =&gt; negative firm capacity
        rightmost = 0
        leftmost = -c
        while compare_itc_to_fc(leftmost) &gt; 0 :
          leftmost -= c
      else:
        leftmost = 0
        rightmost = c
        while compare_itc_to_fc(rightmost) &lt; 0:
          rightmost += c
      
      #print(&#34;finding efc in [{a},{b}]&#34;.format(a=leftmost,b=rightmost))
      efc, res = bisect(f=compare_itc_to_fc,a=leftmost,b=rightmost,full_output=True,xtol=tol/2,rtol=tol/(2*with_itc))
      if not res.converged:
        print(&#34;Warning: EFC estimator did not converge.&#34;)
      #print(&#34;efc:{efc}&#34;.format(efc=efc))
      return int(efc)

  def _trapezoid_prob(self,X,ulc,c):

    &#34;&#34;&#34;Compute the probability mass of a trapezoidal segment of the plane
    # The trapezoid os formed by stacking a right triangle on top of a rectangle
    # where the hypotenuse is facing to the right

    **Parameters**:

    `X` (`BivariateConvGenDist`) bivariate available conventional generation object 
    
    `ulc` (`list`): upper left corner

    `c` (`int`): width of trapezoid

    &#34;&#34;&#34;
    return C_CALL.trapezoid_prob(
                        np.int64(ulc1),
                        np.int64(ulc2),
                        np.int64(c),
                        np.int64(X.X1.min),
                        np.int64(X.X2.min),
                        np.int64(X.X1.max),
                        np.int64(X.X2.max),
                        ffi.cast(&#34;double *&#34;,X.X1.cdf_vals.ctypes.data),
                        ffi.cast(&#34;double *&#34;,X.X2.cdf_vals.ctypes.data))

  def _cond_EPU_share(self,FX1,FX2,d1,d2,v1,v2,c):
    &#34;&#34;&#34;Returns EPU conditional on given demand and wind generations under a share policy

    **Parameters**:
    
    `FX1` (`ConvGenDistribution`): available conventional generation distribution object for area 1

    `FX2` (`ConvGenDistribution`): available conventional generation distribution object for area 2

    `d1` (`int`): demand in area 1

    `d2` (`int`): demand in area 2

    `v1` (`int`): net demand in area 1 (demand - renewable generation)

    `v2` (`int`): net demand in area 2

    `c` (`int`): Interconnector capacity

    &#34;&#34;&#34;

    return C_CALL.cond_epu_share(
                    np.int64(d1),
                    np.int64(d2),
                    np.int64(v1),
                    np.int64(v2),
                    np.int64(c),
                    np.int64(FX1.min),
                    np.int64(FX2.min),
                    np.int64(FX1.max),
                    np.int64(FX2.max),
                    ffi.cast(&#34;double *&#34;,FX1.cdf_vals.ctypes.data),
                    ffi.cast(&#34;double *&#34;,FX2.cdf_vals.ctypes.data),
                    ffi.cast(&#34;double *&#34;,FX1.expectation_vals.ctypes.data))
  
  def _cond_EPU_veto(self,FX1,FX2,v1,v2,c):
    &#34;&#34;&#34;Returns EPU conditional on given demand and wind generations under a veto policy

    **Parameters**:
    
    `FX1` (`ConvGenDistribution`): available conventional generation distribution object for area 1

    `FX2` (`ConvGenDistribution`): available conventional generation distribution object for area 2

    `v1` (`int`): net demand in area 1 (demand - renewable generation)

    `v2` (`int`): net demand in area 2

    `c` (`int`): Interconnector capacity

    &#34;&#34;&#34;

    return C_CALL.cond_epu_veto(
                    np.int64(v1),
                    np.int64(v2),
                    np.int64(c),
                    np.int64(FX1.min),
                    np.int64(FX2.min),
                    np.int64(FX1.max),
                    np.int64(FX2.max),
                    ffi.cast(&#34;double *&#34;,FX1.cdf_vals.ctypes.data),
                    ffi.cast(&#34;double *&#34;,FX2.cdf_vals.ctypes.data),
                    ffi.cast(&#34;double *&#34;,FX1.expectation_vals.ctypes.data))
  
  def _check_null_fc(self):
    if np.any([d.fc != 0 for d in self.gen_dists] + [d.min != 0 for d in self.gen_dists]):
        raise Exception(&#34;Bivariate calculations do not support non-zero firm capacity&#34;)

  def simulate_region(self,n,m,c,policy,intersection=True,seed=1):
    &#34;&#34;&#34; Simulate region of post interconnector power margins

    **Parameters**:
    
    `n` (`int`): number of simulations

    `m` (`tuple`): Upper bound that delimits the region for each component

    `c` (`tuple`): Interconnection capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    `intersection` (`bool`): if `True`, simulate from region given by `m[0] &lt;= m_0 AND m[1] &lt;= m_1` inequality; otherwise from region `m[0] &lt;= m_0 OR m[1] &lt;= m_1`

    `seed` (`int`): random seed
    &#34;&#34;&#34;

    def get_prob_df(m,c,policy,intersection):
      if intersection:
        df = self.cdf(m=m,c=c,policy=policy,get_pointwise_risk=True)
      else:
        if m[0] &gt;= self.MARGIN_BOUND or m[1] &gt;= self.MARGIN_BOUND:
          # the union of anything with constraint &lt;= infinity is the whole plane
          df = self.cdf(m=(self.MARGIN_BOUND,self.MARGIN_BOUND),c=c,policy=policy,get_pointwise_risk=True)
        else:
          df1 = self.cdf(m=(self.MARGIN_BOUND,m[1]),c=c,policy=policy,get_pointwise_risk=True)
          df2 = self.cdf(m=(m[0],self.MARGIN_BOUND),c=c,policy=policy,get_pointwise_risk=True)
          df3 = self.cdf(m=m,c=c,policy=policy,get_pointwise_risk=True)
          union_prob = df1[&#34;value&#34;] + df2[&#34;value&#34;] - df3[&#34;value&#34;]
          df = pd.DataFrame({&#34;value&#34;: union_prob,&#34;nd0&#34;:df3[&#34;nd0&#34;],&#34;nd1&#34;:df3[&#34;nd1&#34;]})

      df[&#34;d0&#34;] = self.demand[:,0]
      df[&#34;d1&#34;] = self.demand[:,1]
      df = df.sort_values(by=&#34;value&#34;,ascending=True)#.query(&#34;value &gt;= 0&#34;) #sometimes rounding errors may 
      # produce negative probabilities in the order of -1e-60
      #print(df)
      return df

    np.random.seed(seed)

    m = np.clip(m,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
    m1, m2 = m

    X1 = self.gen_dists[0]
    X2 = self.gen_dists[1]

    X = BivariateConvGenDist(X1,X2) #system-wide conv. gen. distribution

    simulated = np.ascontiguousarray(np.zeros((n,2)),dtype=np.int64)

    ### calculate conditional probability of each historical observation given
    ### margin value tuple m
    df = get_prob_df(m=m,c=c,policy=policy,intersection=intersection)
    probs = df[&#34;value&#34;]
    total_prob = np.sum(probs)
    if total_prob &lt;= 1e-8:
      raise Exception(&#34;Region has probability lower than 1e-8; too small to simulate accurately&#34;)
    else:
      probs = np.array(probs)/total_prob
      
      df[&#34;row_weights&#34;] = np.random.multinomial(n=n,pvals=probs,size=1).reshape((df.shape[0],))
      ## only pass rows which induce at least one simulated value
      df = df.query(&#34;row_weights &gt; 0&#34;)

      row_weights = np.ascontiguousarray(df[&#34;row_weights&#34;],dtype=np.int64)

      net_demand = np.ascontiguousarray(df[[&#34;nd0&#34;,&#34;nd1&#34;]],dtype=np.int64)

      demand = np.ascontiguousarray(df[[&#34;d0&#34;,&#34;d1&#34;]],dtype=np.int64)

      C_CALL.region_simulation(
        np.int64(n),
        ffi.cast(&#34;long *&#34;,simulated.ctypes.data),
        np.int64(X.X1.min),
        np.int64(X.X2.min),
        np.int64(X.X1.max),
        np.int64(X.X2.max),
        ffi.cast(&#34;double *&#34;,X.X1.cdf_vals.ctypes.data),
        ffi.cast(&#34;double *&#34;,X.X2.cdf_vals.ctypes.data),
        ffi.cast(&#34;long *&#34;,net_demand.ctypes.data),
        ffi.cast(&#34;long *&#34;,demand.ctypes.data),
        ffi.cast(&#34;long *&#34;,row_weights.ctypes.data),
        np.int64(net_demand.shape[0]),
        np.int64(m1),
        np.int64(m2),
        np.int64(c),
        int(seed),
        int(intersection),
        int(policy == &#34;share&#34;))

      return simulated

  def simulate_conditional(self,n,cond_value,cond_axis,c,policy,seed=1):
    &#34;&#34;&#34; Simulate power margins in one area conditioned to a particular value in the other area

    **Parameters**:
    
    `n` (`int`): number of simulated values

    `cond_value` (`int`): conditioning power margin value

    `cond_axis` (`int`): Conditioning component

    `c` (`tuple`): Interconnection capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    `seed` (`int`): random seed
    &#34;&#34;&#34;

    np.random.seed(seed)
    m1 = np.clip(cond_value,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
    m2 = self.MARGIN_BOUND

    if cond_axis == 1:
      self._swap_axes()

    X1 = self.gen_dists[0]
    X2 = self.gen_dists[1]

    X = BivariateConvGenDist(X1,X2) #system-wide conv. gen. distribution

    simulated = np.ascontiguousarray(np.zeros((n,2)),dtype=np.int64)

    ### calculate conditional probability of each historical observation given
    ### margin value tuple m
    df = self.cdf(m=(m1,m2),c=c,policy=policy,get_pointwise_risk=True)    
    df[&#34;value&#34;] = df[&#34;value&#34;] - self.cdf(m=(m1-1,m2),c=c,policy=policy,get_pointwise_risk=True)[&#34;value&#34;]

    df[&#34;d0&#34;] = self.demand[:,0]
    df[&#34;d1&#34;] = self.demand[:,1]

    ## rounding errors can make probabilities negative of the order of 1e-60
    df = df.query(&#34;value &gt; 0&#34;)
    df = df.sort_values(by=&#34;value&#34;,ascending=True)
    probs = df[&#34;value&#34;]
    total_prob = np.sum(probs)
    
    if total_prob &lt;= 1e-8:
      raise Exception(&#34;Region has probability lower than 1e-8; too small to simulate accurately&#34;)
    else:
      probs = np.array(probs)/total_prob
      
      df[&#34;row_weights&#34;] = np.random.multinomial(n=n,pvals=probs,size=1).reshape((df.shape[0],))
      ## only pass rows which induce at least one simulated value
      df = df.query(&#34;row_weights &gt; 0&#34;)

      row_weights = np.ascontiguousarray(df[&#34;row_weights&#34;],dtype=np.int64)

      net_demand = np.ascontiguousarray(df[[&#34;nd0&#34;,&#34;nd1&#34;]],dtype=np.int64)

      demand = np.ascontiguousarray(df[[&#34;d0&#34;,&#34;d1&#34;]],dtype=np.int64)

      C_CALL.conditioned_simulation(
          np.int64(n),
          ffi.cast(&#34;long *&#34;,simulated.ctypes.data),
          np.int64(X.X1.min),
          np.int64(X.X2.min),
          np.int64(X.X1.max),
          np.int64(X.X2.max),
          ffi.cast(&#34;double *&#34;,X.X1.cdf_vals.ctypes.data),
          ffi.cast(&#34;double *&#34;,X.X2.cdf_vals.ctypes.data),
          ffi.cast(&#34;long *&#34;,net_demand.ctypes.data),
          ffi.cast(&#34;long *&#34;,demand.ctypes.data),
          ffi.cast(&#34;long *&#34;,row_weights.ctypes.data),
          np.int64(net_demand.shape[0]),
          np.int64(m1),
          np.int64(c),
          int(seed),
          int(policy == &#34;share&#34;))

    if cond_axis == 1:
      self._swap_axes()

    return simulated[:,1] #first column has variable conditioned on (constant value)

  def cdf(self,m,c=0,policy=&#34;share&#34;,get_pointwise_risk=False):

    &#34;&#34;&#34;Evaluate the CDF of bivariate power margins for a given system configuration under hindcast.

    **Parameters**:
    
    `m` (`tuple`, `list`, or `numpy.ndarray`) point to evaluate in power margin space

    `c` (`int`): Interconnector capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    `get_pointwise_risk` (`str`): return pandas DataFrame with shortfall probabilities induced by each historic observation

    &#34;&#34;&#34;

    m = np.clip(m,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
    m1, m2 = m
    #self._check_null_fc()

    gendist1, gendist2 = self.gen_dists
    #X2 = self.gen_dists[1]

    #X = BivariateConvGenDist(X1,X2) #system-wide conv. gen. distribution
   
    n = self.n

    cdf = 0

    if get_pointwise_risk:
      nd0 = []
      nd1 = []
      cdf_list = []
      
    for i in range(n):
      #print(i)
      v1, v2 = self.net_demand[i,:]

      d1, d2 = self.demand[i,:]

      point_cdf = C_CALL.get_cond_cdf(
                      np.int64(gendist1.min),
                      np.int64(gendist2.min),
                      np.int64(gendist1.max),
                      np.int64(gendist2.max),
                      ffi.cast(&#34;double *&#34;,gendist1.cdf_vals.ctypes.data),
                      ffi.cast(&#34;double *&#34;,gendist2.cdf_vals.ctypes.data),
                      np.int64(m1),
                      np.int64(m2),
                      np.int64(v1),
                      np.int64(v2),
                      np.int64(d1),
                      np.int64(d2),
                      np.int64(c),
                      np.int64(policy == &#34;share&#34;))

      #print(&#34;point cdf: {x}, index: {i}&#34;.format(x=point_cdf, i=i))
      cdf += point_cdf

      #print(v1)
      if get_pointwise_risk:
          nd0.append(v1)
          nd1.append(v2)
          cdf_list.append(point_cdf)

    if get_pointwise_risk:
      pw_df = pd.DataFrame({&#34;nd0&#34;:nd0,&#34;nd1&#34;:nd1,&#34;value&#34;:cdf_list})
      #print(pw_df)
      return pw_df
    else:   
      return cdf/n

    # else:
    #   # if interconnector capacity is zero, use UnivariateHindcastMargin to compute risks
    #   # as it does it more efficiently
    #   margin = UnivariateHindcastMargin(self.gen_dists[0],self.net_demand[:,0])
    #   return margin.lolp()

  def system_lolp(self,c,get_pointwise_risk=False):
    &#34;&#34;&#34;Returns system-wise LOLP

    **Parameters**:
    
    `c` (`int`): Interconnector capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    `get_pointwise_risk` (`str`): return pandas DataFrame with LOLPs for each historic observation

    &#34;&#34;&#34;

    # calculate LOLP
    X1 = self.gen_dists[0]
    X2 = self.gen_dists[1]

    X = BivariateConvGenDist(X1,X2) #system-wide conv. gen. distribution
    
    n = self.n

    LOLP = 0

    if get_pointwise_risk:
      nd0 = []
      nd1 = []
      lolp = []
      
    for i in range(n):
      #print(i)
      v1, v2 = self.net_demand[i,:]
      # system-wide LOLP does not depend on the policy
      #point_LOLP = X.cdf((v1-c-1,math.inf)) + X.cdf((math.inf,v2-c-1)) - X.cdf((v1-c-1,v2-c-1)) + BivariateHindcastMargin._triangle_prob(X,(v1-c-1,v2-c-1),2*c+1)
      point_LOLP = X.cdf((v1-c-1,math.inf)) + X.cdf((math.inf,v2-c-1)) - X.cdf((v1+c,v2-c-1)) + self._trapezoid_prob(X,(v1-c-1,v2+c),2*c)
      LOLP += point_LOLP

      if get_pointwise_risk:
        nd0.append(v1)
        nd1.append(v2)
        lolp.append(point_LOLP)

    if get_pointwise_risk:
      pw_df = pd.DataFrame({&#34;nd0&#34;:nd0,&#34;nd1&#34;:nd1,&#34;value&#34;:lolp})
      return pw_df
    else:    
      return LOLP/n

  def _simulate_conditional_demand_ratio(self,n,cond_value,cond_axis,c,policy,seed=1):

    np.random.seed(seed)
    m1 = np.clip(cond_value,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
    m2 = self.MARGIN_BOUND

    if cond_axis == 1:
      self._swap_axes()

    ### calculate conditional probability of each historical observation given
    ### margin value tuple m
    df = self.cdf(m=(m1,m2),c=c,policy=policy,get_pointwise_risk=True)    
    #df[&#34;value&#34;] = df[&#34;value&#34;] - self.cdf(m=(m1-1,m2),c=c,policy=policy,get_pointwise_risk=True)[&#34;value&#34;]

    df[&#34;d0&#34;] = self.demand[:,0]
    df[&#34;d1&#34;] = self.demand[:,1]

    ## rounding errors can make probabilities negative of the order of 1e-60
    df = df.query(&#34;value &gt; 0&#34;)
    df = df.sort_values(by=&#34;value&#34;,ascending=True)
    probs = df[&#34;value&#34;]
    total_prob = np.sum(probs)
    
    if total_prob &lt;= 1e-8:
      raise Exception(&#34;Region has probability lower than 1e-8; too small to simulate accurately&#34;)
    else:
      probs = np.array(probs)/total_prob
      
      sample_indices = np.random.choice(range(df.shape[0]),size=n,replace=True,p=probs)
      d0 = np.array(df[&#34;d0&#34;])[sample_indices]
      d1 = np.array(df[&#34;d1&#34;])[sample_indices]

      return d0/(d0 + d1)


  def system_lole(self,c,get_pointwise_risk=False):
    &#34;&#34;&#34;Returns system-wise LOLE

    **Parameters**:
    
    `c` (`int`): Interconnector capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    `get_pointwise_risk` (`str`): return pandas DataFrame with system LOLE contributions for each historic observation
    &#34;&#34;&#34;
    return self.n * self.system_lolp(c,get_pointwise_risk)


  def margin_quantile(self,q,i=0,c=0,policy=&#34;veto&#34;):

    &#34;&#34;&#34;Returns quantile of any of the margin distributions

    **Parameters**:
    
    `q` (`float`): quantile

    `i (`int*): area index for which this will be calculated

    `c` (`int`): Interconnector capacity

    `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

    &#34;&#34;&#34;
    def bisection(x):
      y = np.empty((2,))
      y[1-i] = np.Inf
      y[i] = x
      return self.cdf(y,c=c,policy=policy) - q
    
    step = 1000

    lower = 0
    upper = 0

    while bisection(lower) &gt;= 0:
      lower -= step

    while bisection(upper) &lt;= 0:
      upper += step

    return bisect(f=bisection,a=lower,b=upper)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.bivar_ecdf"><code class="name flex">
<span>def <span class="ident">bivar_ecdf</span></span>(<span>X)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def bivar_ecdf(X):
  n = X.shape[0]
  ecdf = np.ascontiguousarray(np.empty((n,)),dtype=np.float64)
  C_CALL.bivar_ecdf(
    ffi.cast(&#34;double *&#34;,ecdf.ctypes.data),
    ffi.cast(&#34;double *&#34;,np.ascontiguousarray(X,dtype=np.float64).ctypes.data),
    np.int64(n))

  return ecdf</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.cdf"><code class="name flex">
<span>def <span class="ident">cdf</span></span>(<span>self, m, c=0, policy='share', get_pointwise_risk=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate the CDF of bivariate power margins for a given system configuration under hindcast.</p>
<p><strong>Parameters</strong>:</p>
<p><code>m</code> (<code>tuple</code>, <code>list</code>, or <code>numpy.ndarray</code>) point to evaluate in power margin space</p>
<p><code>c</code> (<code>int</code>): Interconnector capacity</p>
<p><code>policy</code> (<code>str</code>): Either 'share' or 'veto'</p>
<p><code>get_pointwise_risk</code> (<code>str</code>): return pandas DataFrame with shortfall probabilities induced by each historic observation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cdf(self,m,c=0,policy=&#34;share&#34;,get_pointwise_risk=False):

  &#34;&#34;&#34;Evaluate the CDF of bivariate power margins for a given system configuration under hindcast.

  **Parameters**:
  
  `m` (`tuple`, `list`, or `numpy.ndarray`) point to evaluate in power margin space

  `c` (`int`): Interconnector capacity

  `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

  `get_pointwise_risk` (`str`): return pandas DataFrame with shortfall probabilities induced by each historic observation

  &#34;&#34;&#34;

  m = np.clip(m,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
  m1, m2 = m
  #self._check_null_fc()

  gendist1, gendist2 = self.gen_dists
  #X2 = self.gen_dists[1]

  #X = BivariateConvGenDist(X1,X2) #system-wide conv. gen. distribution
 
  n = self.n

  cdf = 0

  if get_pointwise_risk:
    nd0 = []
    nd1 = []
    cdf_list = []
    
  for i in range(n):
    #print(i)
    v1, v2 = self.net_demand[i,:]

    d1, d2 = self.demand[i,:]

    point_cdf = C_CALL.get_cond_cdf(
                    np.int64(gendist1.min),
                    np.int64(gendist2.min),
                    np.int64(gendist1.max),
                    np.int64(gendist2.max),
                    ffi.cast(&#34;double *&#34;,gendist1.cdf_vals.ctypes.data),
                    ffi.cast(&#34;double *&#34;,gendist2.cdf_vals.ctypes.data),
                    np.int64(m1),
                    np.int64(m2),
                    np.int64(v1),
                    np.int64(v2),
                    np.int64(d1),
                    np.int64(d2),
                    np.int64(c),
                    np.int64(policy == &#34;share&#34;))

    #print(&#34;point cdf: {x}, index: {i}&#34;.format(x=point_cdf, i=i))
    cdf += point_cdf

    #print(v1)
    if get_pointwise_risk:
        nd0.append(v1)
        nd1.append(v2)
        cdf_list.append(point_cdf)

  if get_pointwise_risk:
    pw_df = pd.DataFrame({&#34;nd0&#34;:nd0,&#34;nd1&#34;:nd1,&#34;value&#34;:cdf_list})
    #print(pw_df)
    return pw_df
  else:   
    return cdf/n</code></pre>
</details>
</dd>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.convgen_efc"><code class="name flex">
<span>def <span class="ident">convgen_efc</span></span>(<span>self, cap, prob, gen_axis, fc_axis, c, policy, metric='lole', axis=0, tol=0.1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the amount of firm capacity that needs to be added to area <code>fc_axis</code> such that area <code>axis</code> has the same risk (as defined by <code>metric</code>) than if new conventional generation was installed in <code>gen_axis</code>.</p>
<p><strong>Parameters</strong>:</p>
<p><code>cap</code> (<code>int</code>): maximum available capacity of new generator in MW</p>
<p><code>prob</code> (<code>float</code>): availability probability for the new generator</p>
<p><code>gen_axis</code> (<code>int</code>): Axis to which the new generator will be added</p>
<p><code>fc_axis</code> (<code>int</code>): Area to which firm capacity will be added</p>
<p><code>c</code> (<code>int</code>): interconnection capacity</p>
<p><code>policy</code> (<code>str</code>): Either 'share' or 'veto'</p>
<p><code>axis</code> (<code>int</code>): area for which risk will be calculated</p>
<p><code>metric</code> (<code>string</code>): name of the instance's method that will be used to measure risk. Only 'LOLE' and 'EEU' are supported</p>
<p><code>tol</code> (<code>float</code>): absolute error tolerance from true target risk value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convgen_efc(self, cap, prob, gen_axis, fc_axis, c,policy,metric=&#34;lole&#34;,axis=0,tol=0.1,**kwargs):
  &#34;&#34;&#34;Returns the amount of firm capacity that needs to be added to area `fc_axis` such that area `axis` has the same risk (as defined by `metric`) than if new conventional generation was installed in `gen_axis`.

  **Parameters**:
  
  `cap` (`int`): maximum available capacity of new generator in MW

  `prob` (`float`): availability probability for the new generator

  `gen_axis` (`int`): Axis to which the new generator will be added

  `fc_axis` (`int`): Area to which firm capacity will be added

  `c` (`int`): interconnection capacity

  `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

  `axis` (`int`): area for which risk will be calculated

  `metric` (`string`): name of the instance&#39;s method that will be used to measure risk. Only &#39;LOLE&#39; and &#39;EEU&#39; are supported

  `tol` (`float`): absolute error tolerance from true target risk value

  &#34;&#34;&#34;
  if not (axis in [0,1]):
    raise Exception(&#34;axis value must be 0 or 1&#34;)

  if not (gen_axis in [0,1]):
    raise Exception(&#34;gen_axis value must be 0 or 1&#34;)

  if not (fc_axis in [0,1]):
    raise Exception(&#34;fc_axis value must be 0 or 1&#34;)

  if prob &gt; 1 or prob &lt; 0:
    raise Exception(&#34;Availability value must be between 0 and 1&#34;)

  other = 1 - gen_axis
  gen_data = self.gen_dists[gen_axis].original_data

  # create augmented conv gen distribution
  new_row = pd.Series([cap,prob],index=[&#34;Capacity&#34;,&#34;Availability&#34;])
  augmented_data = gen_data.append(new_row,ignore_index=True)
  augmented_gen_dist = ConvGenDistribution(augmented_data)

  # create augmented conv gen bivariate distribution and get risk metric in agumented system
  new_bivariate_dist = [0,1] #place holder values
  new_bivariate_dist[gen_axis] = augmented_gen_dist
  new_bivariate_dist[other] = self.gen_dists[other]
  new_margin_dist = BivariateHindcastMargin(self.demand,self.renewables,new_bivariate_dist)
  new_metric_func = getattr(new_margin_dist,metric)
  new_metric_val = new_metric_func(c=c,policy=policy,axis=axis)

  print(&#34;new metric val: {x}&#34;.format(x=new_metric_val))
  ### take original system and add firm capacity until we get new_metric_val
  # define bisection algorithm&#39;s bounds
  if cap &gt;= 0:
    leftmost = 0
    rightmost = cap
  else:
    rightmost = 0
    leftmost = cap

  # clone object to prevent any side effects
  original_bivariate_dist = [ConvGenDistribution(self.gen_dists[area].original_data) for area in range(2)]
  
  # define objective for bisection algorithm
  def find_efc(x):
    # add firm capacity
    original_bivariate_dist[fc_axis] += x
    # create bivariate margin distribution object
    dist = BivariateHindcastMargin(self.demand,self.renewables,original_bivariate_dist)
    metric_func = getattr(dist,metric)
    metric_val = metric_func(c=c,policy=policy,axis=axis)

    # reset firm capacity to 0
    original_bivariate_dist[fc_axis] += (-original_bivariate_dist[fc_axis].fc)

    print(&#34;Adding {x}, getting val {v}&#34;.format(x=x,v=metric_val))
    return metric_val - new_metric_val

  efc, res = bisect(f=find_efc,a=leftmost,b=rightmost,full_output=True,xtol=tol/2,rtol=tol/(2*new_metric_val))
  if not res.converged:
    print(&#34;Warning: EFC estimator did not converge.&#34;)
  #print(&#34;efc:{efc}&#34;.format(efc=efc))
  return int(efc)</code></pre>
</details>
</dd>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.eeu"><code class="name flex">
<span>def <span class="ident">eeu</span></span>(<span>self, c, policy, axis=0, get_pointwise_risk=False)</span>
</code></dt>
<dd>
<div class="desc"><p>calculate EEU for one of the areas</p>
<p><strong>Parameters</strong>:</p>
<p><code>c</code> (<code>int</code>): Interconnector capacity</p>
<p><code>policy</code> (<code>str</code>): either 'veto' or 'share'</p>
<p><code>axis</code> (<code>int</code>): area index for which this will be calculated </p>
<p><code>get_pointwise_risk (</code>bool<code>): If</code>True`, returns pandas dataframe with EEU contributions for each historic observation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eeu(self,c,policy,axis=0,get_pointwise_risk=False):
  &#34;&#34;&#34;calculate EEU for one of the areas

  **Parameters**:
  
  `c` (`int`): Interconnector capacity

  `policy` (`str`): either &#39;veto&#39; or &#39;share&#39;

  `axis` (`int`): area index for which this will be calculated 

  `get_pointwise_risk (`bool`): If `True`, returns pandas dataframe with EEU contributions for each historic observation

  &#34;&#34;&#34;

  if axis == 1:
    self._swap_axes()
  
  epu_vals = self.epu(c=c,policy=policy,get_pointwise_risk=get_pointwise_risk)

  if axis == 1:
    self._swap_axes()

  if get_pointwise_risk:
    return epu_vals
  else:
    return self.n * epu_vals</code></pre>
</details>
</dd>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.efc"><code class="name flex">
<span>def <span class="ident">efc</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This method calculates the equivalent firm capacity of interconnection for a given power system. It has been deprecated; use the <code>itc_efc</code> method instead. When called, this function calls <code>itc_efc</code>, passing all arguments along.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def efc(self,**kwargs):
  &#34;&#34;&#34;This method calculates the equivalent firm capacity of interconnection for a given power system. It has been deprecated; use the `itc_efc` method instead. When called, this function calls `itc_efc`, passing all arguments along.
  &#34;&#34;&#34;
  warn(&#34;This method is deprecated; use methods itc_efc or convgen_ifc instead.&#34;)
  return self.itc_efc(**kwargs)</code></pre>
</details>
</dd>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.epu"><code class="name flex">
<span>def <span class="ident">epu</span></span>(<span>self, c, policy='share', get_pointwise_risk=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns EPU for area 1</p>
<p><strong>Parameters</strong>:</p>
<p><code>c</code> (<code>int</code>): Interconnector capacity</p>
<p><code>policy</code> (<code>str</code>): Either 'share' or 'veto'</p>
<p><code>get_pointwise_risk</code> (<code>str</code>): return pandas DataFrame with EPU for each historic observation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def epu(self,c,policy=&#34;share&#34;,get_pointwise_risk=False):
  &#34;&#34;&#34;Returns EPU for area 1

  **Parameters**:
  
  `c` (`int`): Interconnector capacity

  `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

  `get_pointwise_risk` (`str`): return pandas DataFrame with EPU for each historic observation

  &#34;&#34;&#34;
  if c &gt; 0 or get_pointwise_risk:
    #self._check_null_fc()
    X1 = self.gen_dists[0]
    X2 = self.gen_dists[1]
    n = self.n

    EPU = 0

    if get_pointwise_risk:
      nd0 = []
      nd1 = []
      pu = []
      
    for i in range(n):
      #print(i)
      v1, v2 = self.net_demand[i,:]
      d1, d2 = self.demand[i,:]
      if policy == &#34;share&#34;:
        point_EPU = self._cond_EPU_share(X1,X2,d1,d2,v1,v2,c)
      else:
        point_EPU = self._cond_EPU_veto(X1,X2,v1,v2,c)

      EPU += point_EPU
      
      if get_pointwise_risk:
        nd0.append(v1)
        nd1.append(v2)
        pu.append(point_EPU)

    if get_pointwise_risk:
      pw_df = pd.DataFrame({&#34;nd0&#34;:nd0,&#34;nd1&#34;:nd1,&#34;value&#34;:pu})
      return pw_df 
    else:
      return EPU/n
      #return self.season_hours * EPU/n


  else:
    # if interconnector capacity is zero, use UnivariateHindcastMargin to compute risks
    # as it does it more efficiently
    margin = UnivariateHindcastMargin(self.gen_dists[0],self.net_demand[:,0])
    return margin.epu()</code></pre>
</details>
</dd>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.itc_efc"><code class="name flex">
<span>def <span class="ident">itc_efc</span></span>(<span>self, c, policy, metric='lole', axis=0, tol=0.1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns equivalent firm capacity of interconnector in one area</p>
<p><strong>Parameters</strong>:</p>
<p><code>c</code> (<code>int</code>): interconnection capacity</p>
<p><code>policy</code> (<code>str</code>): Either 'share' or 'veto'</p>
<p><code>axis</code> (<code>int</code>): area for which risk will be calculated</p>
<p><code>metric</code> (<code>string</code>): name of the instance's method that will be used to measure risk</p>
<p><code>tol</code> (<code>float</code>): absolute error tolerance from true target risk value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def itc_efc(self,c,policy,metric=&#34;lole&#34;,axis=0,tol=0.1,**kwargs):
  &#34;&#34;&#34;Returns equivalent firm capacity of interconnector in one area

  **Parameters**:
  
  `c` (`int`): interconnection capacity

  `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

  `axis` (`int`): area for which risk will be calculated

  `metric` (`string`): name of the instance&#39;s method that will be used to measure risk

  `tol` (`float`): absolute error tolerance from true target risk value

  &#34;&#34;&#34;
  if not metric in [&#34;lole&#34;,&#34;eeu&#34;]:
    raise Exception(&#34;Only &#39;lole&#39; or &#39;eeu&#39; supported as risk metrics&#34;)
  
  #target value
  with_itc = getattr(self,metric)(c=c,axis=axis,policy=policy,**kwargs)

  def compare_itc_to_fc(k):
    self.gen_dists[axis] += k ## add firm capacity
    univar = UnivariateHindcastMargin(self.gen_dists[axis],self.net_demand[:,axis])
    #risk_metric = getattr(univar,metric)
    without_itc = getattr(univar,metric)()
    #k_fc_risk =  with_itc - without_itc
    self.gen_dists[axis] += (-k) #reset firm capacity to 0
    return with_itc - without_itc

  diff_to_null = compare_itc_to_fc(0)

  # now find the root of compare_itc_to_fc by bisection

  # is the interconnector adding risk?
  if diff_to_null == 0: #itc is equivalent to null interconnection riskwise
    return 0.0
  else:
    # find suitalbe search intervals that are reasonably small
    if diff_to_null &gt; 0: #interconnector adds risk =&gt; negative firm capacity
      rightmost = 0
      leftmost = -c
      while compare_itc_to_fc(leftmost) &gt; 0 :
        leftmost -= c
    else:
      leftmost = 0
      rightmost = c
      while compare_itc_to_fc(rightmost) &lt; 0:
        rightmost += c
    
    #print(&#34;finding efc in [{a},{b}]&#34;.format(a=leftmost,b=rightmost))
    efc, res = bisect(f=compare_itc_to_fc,a=leftmost,b=rightmost,full_output=True,xtol=tol/2,rtol=tol/(2*with_itc))
    if not res.converged:
      print(&#34;Warning: EFC estimator did not converge.&#34;)
    #print(&#34;efc:{efc}&#34;.format(efc=efc))
    return int(efc)</code></pre>
</details>
</dd>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.lole"><code class="name flex">
<span>def <span class="ident">lole</span></span>(<span>self, c, policy, axis=0, get_pointwise_risk=False)</span>
</code></dt>
<dd>
<div class="desc"><p>calculate LOLE for one of the areas</p>
<p><strong>Parameters</strong>:</p>
<p><code>c</code> (<code>numpy.ndarray</code>): interconnector capacity</p>
<p><code>policy</code> (<code>str</code>): either 'veto' or 'share'</p>
<p><code>axis (</code>int*): area index for which this will be calculated</p>
<p><code>get_pointwise_risk (</code>bool<code>): If</code>True`, returns pandas dataframe with LOLE contributions historic observation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lole(self,c,policy,axis=0,get_pointwise_risk=False):
  &#34;&#34;&#34;calculate LOLE for one of the areas

  **Parameters**:
  
  `c` (`numpy.ndarray`): interconnector capacity

  `policy` (`str`): either &#39;veto&#39; or &#39;share&#39;

  `axis (`int*): area index for which this will be calculated

  `get_pointwise_risk (`bool`): If `True`, returns pandas dataframe with LOLE contributions historic observation

  &#34;&#34;&#34;

  # if axis == 1:
  #   self._swap_axes()

  m = [np.Inf,np.Inf]
  m[axis] = -1
  #m = (-1,np.Inf)
  lolp_vals = self.cdf(m=m,c=c,policy=policy,get_pointwise_risk=get_pointwise_risk) 
  if get_pointwise_risk:
    lole = lolp_vals
  else:
    lole = self.n * lolp_vals

  return lole</code></pre>
</details>
</dd>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.margin_cdf"><code class="name flex">
<span>def <span class="ident">margin_cdf</span></span>(<span>self, x, i=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>calculate bivariate margin CDF values based on a component index</p>
<p><strong>Parameters</strong>:</p>
<p><code>x</code> (<code>numpy.ndarray</code>): margin values</p>
<p><code>x</code> (<code>numpy.ndarray</code>): component index</p>
<p><code>kwargs</code> : additional arguments to be passed to the CDF function (system parameters like policy)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def margin_cdf(self,x,i=0,**kwargs):
  &#34;&#34;&#34;calculate bivariate margin CDF values based on a component index

  **Parameters**:
  
  `x` (`numpy.ndarray`): margin values

  `x` (`numpy.ndarray`): component index

  `kwargs` : additional arguments to be passed to the CDF function (system parameters like policy)


  &#34;&#34;&#34;

  m = (x,self.MARGIN_BOUND) if i == 0 else (self.MARGIN_BOUND,x)
  return self.cdf(m=m,**kwargs)</code></pre>
</details>
</dd>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.margin_quantile"><code class="name flex">
<span>def <span class="ident">margin_quantile</span></span>(<span>self, q, i=0, c=0, policy='veto')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns quantile of any of the margin distributions</p>
<p><strong>Parameters</strong>:</p>
<p><code>q</code> (<code>float</code>): quantile</p>
<p><code>i (</code>int*): area index for which this will be calculated</p>
<p><code>c</code> (<code>int</code>): Interconnector capacity</p>
<p><code>policy</code> (<code>str</code>): Either 'share' or 'veto'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def margin_quantile(self,q,i=0,c=0,policy=&#34;veto&#34;):

  &#34;&#34;&#34;Returns quantile of any of the margin distributions

  **Parameters**:
  
  `q` (`float`): quantile

  `i (`int*): area index for which this will be calculated

  `c` (`int`): Interconnector capacity

  `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

  &#34;&#34;&#34;
  def bisection(x):
    y = np.empty((2,))
    y[1-i] = np.Inf
    y[i] = x
    return self.cdf(y,c=c,policy=policy) - q
  
  step = 1000

  lower = 0
  upper = 0

  while bisection(lower) &gt;= 0:
    lower -= step

  while bisection(upper) &lt;= 0:
    upper += step

  return bisect(f=bisection,a=lower,b=upper)</code></pre>
</details>
</dd>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.pdf"><code class="name flex">
<span>def <span class="ident">pdf</span></span>(<span>self, x, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>calculate bivariate PDF</p>
<p><strong>Parameters</strong>:</p>
<p><code>x</code> (<code>numpy.ndarray</code>): margin values</p>
<p><code>kwargs</code> : additional arguments to be passed to the CDF function (system parameters like policy)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pdf(self,x,**kwargs):
  &#34;&#34;&#34;calculate bivariate PDF

  **Parameters**:
  
  `x` (`numpy.ndarray`): margin values

  `kwargs` : additional arguments to be passed to the CDF function (system parameters like policy)


  &#34;&#34;&#34;

  x = np.int64(x)
  return self.cdf(x,**kwargs) - (self.cdf(x - (1,0),**kwargs) - self.cdf(x - (0,1),**kwargs) + self.cdf(x - (1,1),**kwargs))</code></pre>
</details>
</dd>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.simulate_conditional"><code class="name flex">
<span>def <span class="ident">simulate_conditional</span></span>(<span>self, n, cond_value, cond_axis, c, policy, seed=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate power margins in one area conditioned to a particular value in the other area</p>
<p><strong>Parameters</strong>:</p>
<p><code>n</code> (<code>int</code>): number of simulated values</p>
<p><code>cond_value</code> (<code>int</code>): conditioning power margin value</p>
<p><code>cond_axis</code> (<code>int</code>): Conditioning component</p>
<p><code>c</code> (<code>tuple</code>): Interconnection capacity</p>
<p><code>policy</code> (<code>str</code>): Either 'share' or 'veto'</p>
<p><code>seed</code> (<code>int</code>): random seed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate_conditional(self,n,cond_value,cond_axis,c,policy,seed=1):
  &#34;&#34;&#34; Simulate power margins in one area conditioned to a particular value in the other area

  **Parameters**:
  
  `n` (`int`): number of simulated values

  `cond_value` (`int`): conditioning power margin value

  `cond_axis` (`int`): Conditioning component

  `c` (`tuple`): Interconnection capacity

  `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

  `seed` (`int`): random seed
  &#34;&#34;&#34;

  np.random.seed(seed)
  m1 = np.clip(cond_value,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
  m2 = self.MARGIN_BOUND

  if cond_axis == 1:
    self._swap_axes()

  X1 = self.gen_dists[0]
  X2 = self.gen_dists[1]

  X = BivariateConvGenDist(X1,X2) #system-wide conv. gen. distribution

  simulated = np.ascontiguousarray(np.zeros((n,2)),dtype=np.int64)

  ### calculate conditional probability of each historical observation given
  ### margin value tuple m
  df = self.cdf(m=(m1,m2),c=c,policy=policy,get_pointwise_risk=True)    
  df[&#34;value&#34;] = df[&#34;value&#34;] - self.cdf(m=(m1-1,m2),c=c,policy=policy,get_pointwise_risk=True)[&#34;value&#34;]

  df[&#34;d0&#34;] = self.demand[:,0]
  df[&#34;d1&#34;] = self.demand[:,1]

  ## rounding errors can make probabilities negative of the order of 1e-60
  df = df.query(&#34;value &gt; 0&#34;)
  df = df.sort_values(by=&#34;value&#34;,ascending=True)
  probs = df[&#34;value&#34;]
  total_prob = np.sum(probs)
  
  if total_prob &lt;= 1e-8:
    raise Exception(&#34;Region has probability lower than 1e-8; too small to simulate accurately&#34;)
  else:
    probs = np.array(probs)/total_prob
    
    df[&#34;row_weights&#34;] = np.random.multinomial(n=n,pvals=probs,size=1).reshape((df.shape[0],))
    ## only pass rows which induce at least one simulated value
    df = df.query(&#34;row_weights &gt; 0&#34;)

    row_weights = np.ascontiguousarray(df[&#34;row_weights&#34;],dtype=np.int64)

    net_demand = np.ascontiguousarray(df[[&#34;nd0&#34;,&#34;nd1&#34;]],dtype=np.int64)

    demand = np.ascontiguousarray(df[[&#34;d0&#34;,&#34;d1&#34;]],dtype=np.int64)

    C_CALL.conditioned_simulation(
        np.int64(n),
        ffi.cast(&#34;long *&#34;,simulated.ctypes.data),
        np.int64(X.X1.min),
        np.int64(X.X2.min),
        np.int64(X.X1.max),
        np.int64(X.X2.max),
        ffi.cast(&#34;double *&#34;,X.X1.cdf_vals.ctypes.data),
        ffi.cast(&#34;double *&#34;,X.X2.cdf_vals.ctypes.data),
        ffi.cast(&#34;long *&#34;,net_demand.ctypes.data),
        ffi.cast(&#34;long *&#34;,demand.ctypes.data),
        ffi.cast(&#34;long *&#34;,row_weights.ctypes.data),
        np.int64(net_demand.shape[0]),
        np.int64(m1),
        np.int64(c),
        int(seed),
        int(policy == &#34;share&#34;))

  if cond_axis == 1:
    self._swap_axes()

  return simulated[:,1] #first column has variable conditioned on (constant value)</code></pre>
</details>
</dd>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.simulate_region"><code class="name flex">
<span>def <span class="ident">simulate_region</span></span>(<span>self, n, m, c, policy, intersection=True, seed=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate region of post interconnector power margins</p>
<p><strong>Parameters</strong>:</p>
<p><code>n</code> (<code>int</code>): number of simulations</p>
<p><code>m</code> (<code>tuple</code>): Upper bound that delimits the region for each component</p>
<p><code>c</code> (<code>tuple</code>): Interconnection capacity</p>
<p><code>policy</code> (<code>str</code>): Either 'share' or 'veto'</p>
<p><code>intersection</code> (<code>bool</code>): if <code>True</code>, simulate from region given by <code>m[0] &lt;= m_0 AND m[1] &lt;= m_1</code> inequality; otherwise from region <code>m[0] &lt;= m_0 OR m[1] &lt;= m_1</code></p>
<p><code>seed</code> (<code>int</code>): random seed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate_region(self,n,m,c,policy,intersection=True,seed=1):
  &#34;&#34;&#34; Simulate region of post interconnector power margins

  **Parameters**:
  
  `n` (`int`): number of simulations

  `m` (`tuple`): Upper bound that delimits the region for each component

  `c` (`tuple`): Interconnection capacity

  `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

  `intersection` (`bool`): if `True`, simulate from region given by `m[0] &lt;= m_0 AND m[1] &lt;= m_1` inequality; otherwise from region `m[0] &lt;= m_0 OR m[1] &lt;= m_1`

  `seed` (`int`): random seed
  &#34;&#34;&#34;

  def get_prob_df(m,c,policy,intersection):
    if intersection:
      df = self.cdf(m=m,c=c,policy=policy,get_pointwise_risk=True)
    else:
      if m[0] &gt;= self.MARGIN_BOUND or m[1] &gt;= self.MARGIN_BOUND:
        # the union of anything with constraint &lt;= infinity is the whole plane
        df = self.cdf(m=(self.MARGIN_BOUND,self.MARGIN_BOUND),c=c,policy=policy,get_pointwise_risk=True)
      else:
        df1 = self.cdf(m=(self.MARGIN_BOUND,m[1]),c=c,policy=policy,get_pointwise_risk=True)
        df2 = self.cdf(m=(m[0],self.MARGIN_BOUND),c=c,policy=policy,get_pointwise_risk=True)
        df3 = self.cdf(m=m,c=c,policy=policy,get_pointwise_risk=True)
        union_prob = df1[&#34;value&#34;] + df2[&#34;value&#34;] - df3[&#34;value&#34;]
        df = pd.DataFrame({&#34;value&#34;: union_prob,&#34;nd0&#34;:df3[&#34;nd0&#34;],&#34;nd1&#34;:df3[&#34;nd1&#34;]})

    df[&#34;d0&#34;] = self.demand[:,0]
    df[&#34;d1&#34;] = self.demand[:,1]
    df = df.sort_values(by=&#34;value&#34;,ascending=True)#.query(&#34;value &gt;= 0&#34;) #sometimes rounding errors may 
    # produce negative probabilities in the order of -1e-60
    #print(df)
    return df

  np.random.seed(seed)

  m = np.clip(m,a_min=-self.MARGIN_BOUND,a_max=self.MARGIN_BOUND)
  m1, m2 = m

  X1 = self.gen_dists[0]
  X2 = self.gen_dists[1]

  X = BivariateConvGenDist(X1,X2) #system-wide conv. gen. distribution

  simulated = np.ascontiguousarray(np.zeros((n,2)),dtype=np.int64)

  ### calculate conditional probability of each historical observation given
  ### margin value tuple m
  df = get_prob_df(m=m,c=c,policy=policy,intersection=intersection)
  probs = df[&#34;value&#34;]
  total_prob = np.sum(probs)
  if total_prob &lt;= 1e-8:
    raise Exception(&#34;Region has probability lower than 1e-8; too small to simulate accurately&#34;)
  else:
    probs = np.array(probs)/total_prob
    
    df[&#34;row_weights&#34;] = np.random.multinomial(n=n,pvals=probs,size=1).reshape((df.shape[0],))
    ## only pass rows which induce at least one simulated value
    df = df.query(&#34;row_weights &gt; 0&#34;)

    row_weights = np.ascontiguousarray(df[&#34;row_weights&#34;],dtype=np.int64)

    net_demand = np.ascontiguousarray(df[[&#34;nd0&#34;,&#34;nd1&#34;]],dtype=np.int64)

    demand = np.ascontiguousarray(df[[&#34;d0&#34;,&#34;d1&#34;]],dtype=np.int64)

    C_CALL.region_simulation(
      np.int64(n),
      ffi.cast(&#34;long *&#34;,simulated.ctypes.data),
      np.int64(X.X1.min),
      np.int64(X.X2.min),
      np.int64(X.X1.max),
      np.int64(X.X2.max),
      ffi.cast(&#34;double *&#34;,X.X1.cdf_vals.ctypes.data),
      ffi.cast(&#34;double *&#34;,X.X2.cdf_vals.ctypes.data),
      ffi.cast(&#34;long *&#34;,net_demand.ctypes.data),
      ffi.cast(&#34;long *&#34;,demand.ctypes.data),
      ffi.cast(&#34;long *&#34;,row_weights.ctypes.data),
      np.int64(net_demand.shape[0]),
      np.int64(m1),
      np.int64(m2),
      np.int64(c),
      int(seed),
      int(intersection),
      int(policy == &#34;share&#34;))

    return simulated</code></pre>
</details>
</dd>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.system_eeu"><code class="name flex">
<span>def <span class="ident">system_eeu</span></span>(<span>self, c, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>calculate system-wide EEU</p>
<p><strong>Parameters</strong>:</p>
<p><code>c</code> (<code>int</code>): Interconnector capacity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def system_eeu(self,c,**kwargs):

  &#34;&#34;&#34;calculate system-wide EEU

  **Parameters**:
  
  `c` (`int`): Interconnector capacity

  &#34;&#34;&#34;
  return self.eeu(c,axis=0,**kwargs) + self.eeu(c,axis=1,**kwags)</code></pre>
</details>
</dd>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.system_lole"><code class="name flex">
<span>def <span class="ident">system_lole</span></span>(<span>self, c, get_pointwise_risk=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns system-wise LOLE</p>
<p><strong>Parameters</strong>:</p>
<p><code>c</code> (<code>int</code>): Interconnector capacity</p>
<p><code>policy</code> (<code>str</code>): Either 'share' or 'veto'</p>
<p><code>get_pointwise_risk</code> (<code>str</code>): return pandas DataFrame with system LOLE contributions for each historic observation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def system_lole(self,c,get_pointwise_risk=False):
  &#34;&#34;&#34;Returns system-wise LOLE

  **Parameters**:
  
  `c` (`int`): Interconnector capacity

  `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

  `get_pointwise_risk` (`str`): return pandas DataFrame with system LOLE contributions for each historic observation
  &#34;&#34;&#34;
  return self.n * self.system_lolp(c,get_pointwise_risk)</code></pre>
</details>
</dd>
<dt id="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.system_lolp"><code class="name flex">
<span>def <span class="ident">system_lolp</span></span>(<span>self, c, get_pointwise_risk=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns system-wise LOLP</p>
<p><strong>Parameters</strong>:</p>
<p><code>c</code> (<code>int</code>): Interconnector capacity</p>
<p><code>policy</code> (<code>str</code>): Either 'share' or 'veto'</p>
<p><code>get_pointwise_risk</code> (<code>str</code>): return pandas DataFrame with LOLPs for each historic observation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def system_lolp(self,c,get_pointwise_risk=False):
  &#34;&#34;&#34;Returns system-wise LOLP

  **Parameters**:
  
  `c` (`int`): Interconnector capacity

  `policy` (`str`): Either &#39;share&#39; or &#39;veto&#39;

  `get_pointwise_risk` (`str`): return pandas DataFrame with LOLPs for each historic observation

  &#34;&#34;&#34;

  # calculate LOLP
  X1 = self.gen_dists[0]
  X2 = self.gen_dists[1]

  X = BivariateConvGenDist(X1,X2) #system-wide conv. gen. distribution
  
  n = self.n

  LOLP = 0

  if get_pointwise_risk:
    nd0 = []
    nd1 = []
    lolp = []
    
  for i in range(n):
    #print(i)
    v1, v2 = self.net_demand[i,:]
    # system-wide LOLP does not depend on the policy
    #point_LOLP = X.cdf((v1-c-1,math.inf)) + X.cdf((math.inf,v2-c-1)) - X.cdf((v1-c-1,v2-c-1)) + BivariateHindcastMargin._triangle_prob(X,(v1-c-1,v2-c-1),2*c+1)
    point_LOLP = X.cdf((v1-c-1,math.inf)) + X.cdf((math.inf,v2-c-1)) - X.cdf((v1+c,v2-c-1)) + self._trapezoid_prob(X,(v1-c-1,v2+c),2*c)
    LOLP += point_LOLP

    if get_pointwise_risk:
      nd0.append(v1)
      nd1.append(v2)
      lolp.append(point_LOLP)

  if get_pointwise_risk:
    pw_df = pd.DataFrame({&#34;nd0&#34;:nd0,&#34;nd1&#34;:nd1,&#34;value&#34;:lolp})
    return pw_df
  else:    
    return LOLP/n</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="psrmodels.time_collapsed" href="index.html">psrmodels.time_collapsed</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin">BivariateHindcastMargin</a></code></h4>
<ul class="">
<li><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.bivar_ecdf" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.bivar_ecdf">bivar_ecdf</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.cdf" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.cdf">cdf</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.convgen_efc" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.convgen_efc">convgen_efc</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.eeu" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.eeu">eeu</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.efc" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.efc">efc</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.epu" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.epu">epu</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.itc_efc" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.itc_efc">itc_efc</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.lole" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.lole">lole</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.margin_cdf" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.margin_cdf">margin_cdf</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.margin_quantile" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.margin_quantile">margin_quantile</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.pdf" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.pdf">pdf</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.simulate_conditional" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.simulate_conditional">simulate_conditional</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.simulate_region" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.simulate_region">simulate_region</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.system_eeu" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.system_eeu">system_eeu</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.system_lole" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.system_lole">system_lole</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.system_lolp" href="#psrmodels.time_collapsed.BivariateHindcastMargin.BivariateHindcastMargin.system_lolp">system_lolp</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>