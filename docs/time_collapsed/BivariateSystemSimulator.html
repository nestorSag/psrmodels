<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>psrmodels.time_collapsed.BivariateSystemSimulator API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>psrmodels.time_collapsed.BivariateSystemSimulator</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import pandas as pd
import functools

from .BivariateConvGenDist import * 

class BivariateSystemSimulator(object):
  &#34;&#34;&#34;This class outputs risk metrics MC estimates from a general net demand simulation model, for a 2-area system unver a veto policy
  
  **Parameters**:

  `gen_dists` (`list`): list of available conventional generation distributions

  `net_demand_dist` (`object`): object from which  the system&#39;s net demand is simualated, e.g. HindcastModel, BivariateLogisticNetDemand. It has to have a simulate() method

  &#34;&#34;&#34;

  def __init__(self,gen_dists,net_demand_dist):

    self.gens = gen_dists

    self.net_demand = net_demand_dist

    self.d = len(self.gens)

  def _pu(self,m):
    m[m&gt;=0] = 0
    return -m
  
  def _veto_flow(self,m,c):
    &#34;&#34;&#34;calculate available flow in a veto policy for given margins and interconnector capacity

    **Parameters**:

    `m` (`numpy.ndarray`): margin values

    `c` (`int`): interconnector capacity

    &#34;&#34;&#34;
    i = 0
    j = 1

    delta = np.zeros((self.d,))
    
    # calculate flow to i
    if m[i] &lt; 0 and m[j] &gt; 0:
      flow = np.min(np.array([-m[i],m[j],c]))
    elif m[i] &gt; 0 and m[j] &lt; 0:
      flow = -np.min(np.array([m[i],-m[j],c]))
    else:
      flow = 0

    delta[i] = flow
    delta[j] = -flow
    
    return m + delta

  def _simulate(self,n,seed=1,**kwargs):

    nd = self.net_demand.simulate(n=n,seed=seed,**kwargs)

    bigen = BivariateConvGenDist(self.gens[0],self.gens[1])
    gen = bigen.simulate(n=n,seed=seed)

    return gen, nd

  def simulate(self,n,seed=1,**kwargs):
    &#34;&#34;&#34;Simulate pre-interconnector margins 
  
    **Parameters**:

    `n` (`int`): number of samples

    `seed` (`int`): random seed

    Additional arguments are passed directly to the simulate() method from the net demand model class, and the arguments are also stringified and added as an string column in the results data frame

    &#34;&#34;&#34;

    gen, nd = self._simulate(n,seed,**kwargs)

    return gen - nd

  def simulate_veto(self,n,c,seed=1,**kwargs):

    return np.apply_along_axis(lambda m: self._veto_flow(m,c),1,self.simulate(n,seed,**kwargs))


  def veto_risk(self,n,c,seed,period_length=3360,**kwargs):

    &#34;&#34;&#34;Simulate veto policy and returns MC estimates of LOLE and EPU for different system areas wrapped in a SimulationResults object
  
    **Parameters**:

    `n` (`int`): number of samples

    `c` (`int`): interconnector capacity

    `seed` (`int`): random seed

    `period_length` (`int`): number of time steps in period of interests. Default to 3,360: the number of hours in a peak season in GB

    Additional arguments are passed directly to the simulate() method from the net demand model class, and the arguments are also stringified and added as an string column in the results data frame

    &#34;&#34;&#34;
    
    gen, nd = self._simulate(n,seed,**kwargs)

    margins = gen - nd

    post_itc_margins = np.apply_along_axis(lambda m: self._veto_flow(m,c),1,margins)

    lole_vector = np.apply_along_axis(lambda m: (m &lt; 0).astype(int),1,post_itc_margins)

    eeu_vector = np.apply_along_axis(lambda m: self._pu(m),1,post_itc_margins)
  
    system_lole_vector = np.sum(lole_vector,axis=1)
    system_eeu_vector = np.sum(eeu_vector,axis=1)

    mean_vals = period_length * np.concatenate([
      np.mean(lole_vector,axis=0).reshape((2,)),
      np.mean(eeu_vector,axis=0).reshape((2,)),
      np.mean(system_lole_vector).reshape((1,)),
      np.mean(system_eeu_vector).reshape((1,))])

    sd_vals = period_length * np.concatenate([
      (np.std(lole_vector,axis=0)/np.sqrt(n)).reshape((2,)),
      (np.std(eeu_vector,axis=0)/np.sqrt(n)).reshape((2,)),
      (np.std(system_lole_vector)/np.sqrt(n)).reshape((1,)),
      (np.std(system_eeu_vector)/np.sqrt(n)).reshape((1,))])

    area_vector = [&#34;A1&#34;,&#34;A2&#34;,&#34;A1&#34;,&#34;A2&#34;,&#34;SYS&#34;,&#34;SYS&#34;]
    metric_vector = [&#34;LOLE&#34;,&#34;LOLE&#34;,&#34;EEU&#34;,&#34;EEU&#34;,&#34;LOLE&#34;,&#34;EEU&#34;]

    results_df = pd.DataFrame({
      &#34;mean_val&#34;:mean_vals,
      &#34;mean_sd&#34;:sd_vals,
      &#34;area&#34;:area_vector,
      &#34;metric&#34;:metric_vector})

    results_df[&#34;c&#34;] = c
    results_df[&#34;n&#34;] = n
    results_df[&#34;params&#34;] = str(kwargs)
    results_df[&#34;net_demand_info&#34;] = self.net_demand.__class__.__name__

    # results[&#34;lolp&#34;] = {&#34;mean&#34;:np.mean(lolp_vector,axis=0),&#34;sd&#34;:np.std(lolp_vector,axis=0)/np.sqrt(n)}
    # results[&#34;epu&#34;] = {&#34;mean&#34;:np.mean(epu_vector,axis=0),&#34;sd&#34;:np.std(epu_vector,axis=0)/np.sqrt(n)}

    # results[&#34;system_lolp&#34;] = {&#34;mean&#34;:np.mean(system_lolp_vector),&#34;sd&#34;:np.std(system_lolp_vector)/np.sqrt(n)}
    # results[&#34;system_epu&#34;] = {&#34;mean&#34;:np.mean(system_epu_vector),&#34;sd&#34;:np.std(system_epu_vector)/np.sqrt(n)}

    # res = SimulationResults(
    #   results=results,
    #   n=k+bc,
    #   sim_class=self.net_demand.__class__.__name__,
    #   d=self.d,
    #   c=c,
    #   **kwargs)
  
    # results_list.append(res)

    # loss_events_idx = system_lole_vector &gt; 0

    # loss_events_df = pd.DataFrame(
    #   np.concatenate((
    #     nd[loss_events_idx,:],
    #     margins[loss_events_idx,:],
    #     eeu_vector[loss_events_idx,:]),
    #     axis=1),
    #   columns = [&#34;nd0&#34;,&#34;nd1&#34;,&#34;gen0&#34;,&#34;gen1&#34;,&#34;pu0&#34;,&#34;pu1&#34;])
    
    return results_df#, loss_events_df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="psrmodels.time_collapsed.BivariateSystemSimulator.BivariateSystemSimulator"><code class="flex name class">
<span>class <span class="ident">BivariateSystemSimulator</span></span>
<span>(</span><span>gen_dists, net_demand_dist)</span>
</code></dt>
<dd>
<div class="desc"><p>This class outputs risk metrics MC estimates from a general net demand simulation model, for a 2-area system unver a veto policy</p>
<p><strong>Parameters</strong>:</p>
<p><code>gen_dists</code> (<code>list</code>): list of available conventional generation distributions</p>
<p><code>net_demand_dist</code> (<code>object</code>): object from which
the system's net demand is simualated, e.g. HindcastModel, BivariateLogisticNetDemand. It has to have a simulate() method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BivariateSystemSimulator(object):
  &#34;&#34;&#34;This class outputs risk metrics MC estimates from a general net demand simulation model, for a 2-area system unver a veto policy
  
  **Parameters**:

  `gen_dists` (`list`): list of available conventional generation distributions

  `net_demand_dist` (`object`): object from which  the system&#39;s net demand is simualated, e.g. HindcastModel, BivariateLogisticNetDemand. It has to have a simulate() method

  &#34;&#34;&#34;

  def __init__(self,gen_dists,net_demand_dist):

    self.gens = gen_dists

    self.net_demand = net_demand_dist

    self.d = len(self.gens)

  def _pu(self,m):
    m[m&gt;=0] = 0
    return -m
  
  def _veto_flow(self,m,c):
    &#34;&#34;&#34;calculate available flow in a veto policy for given margins and interconnector capacity

    **Parameters**:

    `m` (`numpy.ndarray`): margin values

    `c` (`int`): interconnector capacity

    &#34;&#34;&#34;
    i = 0
    j = 1

    delta = np.zeros((self.d,))
    
    # calculate flow to i
    if m[i] &lt; 0 and m[j] &gt; 0:
      flow = np.min(np.array([-m[i],m[j],c]))
    elif m[i] &gt; 0 and m[j] &lt; 0:
      flow = -np.min(np.array([m[i],-m[j],c]))
    else:
      flow = 0

    delta[i] = flow
    delta[j] = -flow
    
    return m + delta

  def _simulate(self,n,seed=1,**kwargs):

    nd = self.net_demand.simulate(n=n,seed=seed,**kwargs)

    bigen = BivariateConvGenDist(self.gens[0],self.gens[1])
    gen = bigen.simulate(n=n,seed=seed)

    return gen, nd

  def simulate(self,n,seed=1,**kwargs):
    &#34;&#34;&#34;Simulate pre-interconnector margins 
  
    **Parameters**:

    `n` (`int`): number of samples

    `seed` (`int`): random seed

    Additional arguments are passed directly to the simulate() method from the net demand model class, and the arguments are also stringified and added as an string column in the results data frame

    &#34;&#34;&#34;

    gen, nd = self._simulate(n,seed,**kwargs)

    return gen - nd

  def simulate_veto(self,n,c,seed=1,**kwargs):

    return np.apply_along_axis(lambda m: self._veto_flow(m,c),1,self.simulate(n,seed,**kwargs))


  def veto_risk(self,n,c,seed,period_length=3360,**kwargs):

    &#34;&#34;&#34;Simulate veto policy and returns MC estimates of LOLE and EPU for different system areas wrapped in a SimulationResults object
  
    **Parameters**:

    `n` (`int`): number of samples

    `c` (`int`): interconnector capacity

    `seed` (`int`): random seed

    `period_length` (`int`): number of time steps in period of interests. Default to 3,360: the number of hours in a peak season in GB

    Additional arguments are passed directly to the simulate() method from the net demand model class, and the arguments are also stringified and added as an string column in the results data frame

    &#34;&#34;&#34;
    
    gen, nd = self._simulate(n,seed,**kwargs)

    margins = gen - nd

    post_itc_margins = np.apply_along_axis(lambda m: self._veto_flow(m,c),1,margins)

    lole_vector = np.apply_along_axis(lambda m: (m &lt; 0).astype(int),1,post_itc_margins)

    eeu_vector = np.apply_along_axis(lambda m: self._pu(m),1,post_itc_margins)
  
    system_lole_vector = np.sum(lole_vector,axis=1)
    system_eeu_vector = np.sum(eeu_vector,axis=1)

    mean_vals = period_length * np.concatenate([
      np.mean(lole_vector,axis=0).reshape((2,)),
      np.mean(eeu_vector,axis=0).reshape((2,)),
      np.mean(system_lole_vector).reshape((1,)),
      np.mean(system_eeu_vector).reshape((1,))])

    sd_vals = period_length * np.concatenate([
      (np.std(lole_vector,axis=0)/np.sqrt(n)).reshape((2,)),
      (np.std(eeu_vector,axis=0)/np.sqrt(n)).reshape((2,)),
      (np.std(system_lole_vector)/np.sqrt(n)).reshape((1,)),
      (np.std(system_eeu_vector)/np.sqrt(n)).reshape((1,))])

    area_vector = [&#34;A1&#34;,&#34;A2&#34;,&#34;A1&#34;,&#34;A2&#34;,&#34;SYS&#34;,&#34;SYS&#34;]
    metric_vector = [&#34;LOLE&#34;,&#34;LOLE&#34;,&#34;EEU&#34;,&#34;EEU&#34;,&#34;LOLE&#34;,&#34;EEU&#34;]

    results_df = pd.DataFrame({
      &#34;mean_val&#34;:mean_vals,
      &#34;mean_sd&#34;:sd_vals,
      &#34;area&#34;:area_vector,
      &#34;metric&#34;:metric_vector})

    results_df[&#34;c&#34;] = c
    results_df[&#34;n&#34;] = n
    results_df[&#34;params&#34;] = str(kwargs)
    results_df[&#34;net_demand_info&#34;] = self.net_demand.__class__.__name__

    # results[&#34;lolp&#34;] = {&#34;mean&#34;:np.mean(lolp_vector,axis=0),&#34;sd&#34;:np.std(lolp_vector,axis=0)/np.sqrt(n)}
    # results[&#34;epu&#34;] = {&#34;mean&#34;:np.mean(epu_vector,axis=0),&#34;sd&#34;:np.std(epu_vector,axis=0)/np.sqrt(n)}

    # results[&#34;system_lolp&#34;] = {&#34;mean&#34;:np.mean(system_lolp_vector),&#34;sd&#34;:np.std(system_lolp_vector)/np.sqrt(n)}
    # results[&#34;system_epu&#34;] = {&#34;mean&#34;:np.mean(system_epu_vector),&#34;sd&#34;:np.std(system_epu_vector)/np.sqrt(n)}

    # res = SimulationResults(
    #   results=results,
    #   n=k+bc,
    #   sim_class=self.net_demand.__class__.__name__,
    #   d=self.d,
    #   c=c,
    #   **kwargs)
  
    # results_list.append(res)

    # loss_events_idx = system_lole_vector &gt; 0

    # loss_events_df = pd.DataFrame(
    #   np.concatenate((
    #     nd[loss_events_idx,:],
    #     margins[loss_events_idx,:],
    #     eeu_vector[loss_events_idx,:]),
    #     axis=1),
    #   columns = [&#34;nd0&#34;,&#34;nd1&#34;,&#34;gen0&#34;,&#34;gen1&#34;,&#34;pu0&#34;,&#34;pu1&#34;])
    
    return results_df#, loss_events_df</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="psrmodels.time_collapsed.BivariateSystemSimulator.BivariateSystemSimulator.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self, n, seed=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate pre-interconnector margins </p>
<p><strong>Parameters</strong>:</p>
<p><code>n</code> (<code>int</code>): number of samples</p>
<p><code>seed</code> (<code>int</code>): random seed</p>
<p>Additional arguments are passed directly to the simulate() method from the net demand model class, and the arguments are also stringified and added as an string column in the results data frame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self,n,seed=1,**kwargs):
  &#34;&#34;&#34;Simulate pre-interconnector margins 

  **Parameters**:

  `n` (`int`): number of samples

  `seed` (`int`): random seed

  Additional arguments are passed directly to the simulate() method from the net demand model class, and the arguments are also stringified and added as an string column in the results data frame

  &#34;&#34;&#34;

  gen, nd = self._simulate(n,seed,**kwargs)

  return gen - nd</code></pre>
</details>
</dd>
<dt id="psrmodels.time_collapsed.BivariateSystemSimulator.BivariateSystemSimulator.simulate_veto"><code class="name flex">
<span>def <span class="ident">simulate_veto</span></span>(<span>self, n, c, seed=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate_veto(self,n,c,seed=1,**kwargs):

  return np.apply_along_axis(lambda m: self._veto_flow(m,c),1,self.simulate(n,seed,**kwargs))</code></pre>
</details>
</dd>
<dt id="psrmodels.time_collapsed.BivariateSystemSimulator.BivariateSystemSimulator.veto_risk"><code class="name flex">
<span>def <span class="ident">veto_risk</span></span>(<span>self, n, c, seed, period_length=3360, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate veto policy and returns MC estimates of LOLE and EPU for different system areas wrapped in a SimulationResults object</p>
<p><strong>Parameters</strong>:</p>
<p><code>n</code> (<code>int</code>): number of samples</p>
<p><code>c</code> (<code>int</code>): interconnector capacity</p>
<p><code>seed</code> (<code>int</code>): random seed</p>
<p><code>period_length</code> (<code>int</code>): number of time steps in period of interests. Default to 3,360: the number of hours in a peak season in GB</p>
<p>Additional arguments are passed directly to the simulate() method from the net demand model class, and the arguments are also stringified and added as an string column in the results data frame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def veto_risk(self,n,c,seed,period_length=3360,**kwargs):

  &#34;&#34;&#34;Simulate veto policy and returns MC estimates of LOLE and EPU for different system areas wrapped in a SimulationResults object

  **Parameters**:

  `n` (`int`): number of samples

  `c` (`int`): interconnector capacity

  `seed` (`int`): random seed

  `period_length` (`int`): number of time steps in period of interests. Default to 3,360: the number of hours in a peak season in GB

  Additional arguments are passed directly to the simulate() method from the net demand model class, and the arguments are also stringified and added as an string column in the results data frame

  &#34;&#34;&#34;
  
  gen, nd = self._simulate(n,seed,**kwargs)

  margins = gen - nd

  post_itc_margins = np.apply_along_axis(lambda m: self._veto_flow(m,c),1,margins)

  lole_vector = np.apply_along_axis(lambda m: (m &lt; 0).astype(int),1,post_itc_margins)

  eeu_vector = np.apply_along_axis(lambda m: self._pu(m),1,post_itc_margins)

  system_lole_vector = np.sum(lole_vector,axis=1)
  system_eeu_vector = np.sum(eeu_vector,axis=1)

  mean_vals = period_length * np.concatenate([
    np.mean(lole_vector,axis=0).reshape((2,)),
    np.mean(eeu_vector,axis=0).reshape((2,)),
    np.mean(system_lole_vector).reshape((1,)),
    np.mean(system_eeu_vector).reshape((1,))])

  sd_vals = period_length * np.concatenate([
    (np.std(lole_vector,axis=0)/np.sqrt(n)).reshape((2,)),
    (np.std(eeu_vector,axis=0)/np.sqrt(n)).reshape((2,)),
    (np.std(system_lole_vector)/np.sqrt(n)).reshape((1,)),
    (np.std(system_eeu_vector)/np.sqrt(n)).reshape((1,))])

  area_vector = [&#34;A1&#34;,&#34;A2&#34;,&#34;A1&#34;,&#34;A2&#34;,&#34;SYS&#34;,&#34;SYS&#34;]
  metric_vector = [&#34;LOLE&#34;,&#34;LOLE&#34;,&#34;EEU&#34;,&#34;EEU&#34;,&#34;LOLE&#34;,&#34;EEU&#34;]

  results_df = pd.DataFrame({
    &#34;mean_val&#34;:mean_vals,
    &#34;mean_sd&#34;:sd_vals,
    &#34;area&#34;:area_vector,
    &#34;metric&#34;:metric_vector})

  results_df[&#34;c&#34;] = c
  results_df[&#34;n&#34;] = n
  results_df[&#34;params&#34;] = str(kwargs)
  results_df[&#34;net_demand_info&#34;] = self.net_demand.__class__.__name__

  # results[&#34;lolp&#34;] = {&#34;mean&#34;:np.mean(lolp_vector,axis=0),&#34;sd&#34;:np.std(lolp_vector,axis=0)/np.sqrt(n)}
  # results[&#34;epu&#34;] = {&#34;mean&#34;:np.mean(epu_vector,axis=0),&#34;sd&#34;:np.std(epu_vector,axis=0)/np.sqrt(n)}

  # results[&#34;system_lolp&#34;] = {&#34;mean&#34;:np.mean(system_lolp_vector),&#34;sd&#34;:np.std(system_lolp_vector)/np.sqrt(n)}
  # results[&#34;system_epu&#34;] = {&#34;mean&#34;:np.mean(system_epu_vector),&#34;sd&#34;:np.std(system_epu_vector)/np.sqrt(n)}

  # res = SimulationResults(
  #   results=results,
  #   n=k+bc,
  #   sim_class=self.net_demand.__class__.__name__,
  #   d=self.d,
  #   c=c,
  #   **kwargs)

  # results_list.append(res)

  # loss_events_idx = system_lole_vector &gt; 0

  # loss_events_df = pd.DataFrame(
  #   np.concatenate((
  #     nd[loss_events_idx,:],
  #     margins[loss_events_idx,:],
  #     eeu_vector[loss_events_idx,:]),
  #     axis=1),
  #   columns = [&#34;nd0&#34;,&#34;nd1&#34;,&#34;gen0&#34;,&#34;gen1&#34;,&#34;pu0&#34;,&#34;pu1&#34;])
  
  return results_df#, loss_events_df</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="psrmodels.time_collapsed" href="index.html">psrmodels.time_collapsed</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="psrmodels.time_collapsed.BivariateSystemSimulator.BivariateSystemSimulator" href="#psrmodels.time_collapsed.BivariateSystemSimulator.BivariateSystemSimulator">BivariateSystemSimulator</a></code></h4>
<ul class="">
<li><code><a title="psrmodels.time_collapsed.BivariateSystemSimulator.BivariateSystemSimulator.simulate" href="#psrmodels.time_collapsed.BivariateSystemSimulator.BivariateSystemSimulator.simulate">simulate</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateSystemSimulator.BivariateSystemSimulator.simulate_veto" href="#psrmodels.time_collapsed.BivariateSystemSimulator.BivariateSystemSimulator.simulate_veto">simulate_veto</a></code></li>
<li><code><a title="psrmodels.time_collapsed.BivariateSystemSimulator.BivariateSystemSimulator.veto_risk" href="#psrmodels.time_collapsed.BivariateSystemSimulator.BivariateSystemSimulator.veto_risk">veto_risk</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>